use std::{
    collections::HashMap,
    fs,
    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},
    path::{Path, PathBuf},
    sync::{Arc, Mutex, RwLock},
    time::SystemTime,
};
//Modules used for posting the json data to server & validating the expiry date
use reqwest;
use serde_json::json;
use serde_json::Value as JsonValue;
use chrono::Utc;
use chrono::NaiveDateTime;
use chrono::NaiveDate;
use chrono::{ Local};
extern crate machine_uid;
use uuid::Uuid;
//Modules used for posting the json data to server & validating the expiry date
use anyhow::Result;
use rand::Rng;
use regex::Regex;
use serde as de;
use serde_derive::{Deserialize, Serialize};
use sodiumoxide::base64;
use sodiumoxide::crypto::sign;
use once_cell::sync::Lazy;
use crate::{
    log,
    password_security::{
        decrypt_str_or_original, decrypt_vec_or_original, encrypt_str_or_original,
        encrypt_vec_or_original,
    },
};

pub const RENDEZVOUS_TIMEOUT: u64 = 12_000;
pub const CONNECT_TIMEOUT: u64 = 18_000;
pub const READ_TIMEOUT: u64 = 30_000;
pub const REG_INTERVAL: i64 = 12_000;
pub const COMPRESS_LEVEL: i32 = 3;
const SERIAL: i32 = 3;
const PASSWORD_ENC_VERSION: &str = "00";
// 128x128
#[cfg(not(target_os = "macos"))] // 128x128 on 160x160 canvas, then shrink to 128, mac looks better with padding
pub const ICON: &str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIYAAACGCAYAAAAYefKRAAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nIy9d7xuSVXn/a2qvfcTTro5dM6B0NKKjaTWARziDDKfYRRBmdExATrvzKsi+pmkAoZRRxRGHRXEQPBFXwEDoL7EQVAbaFKHe7v79u3um+/JT9i7qtb7R4W9n+ec27I/n3OetPeuqlWr1vqtUGurI9/wQqF7SP6HCKBARLDWUpgCdp4czxVQivbCdHjibeKtO+e1F8/dVUAUgqIsK4zWTCbbKBQojYggeFS+XLB1016vVeirAt1pQkTw4hERtFIopXd0pdsdlTvdjtZ5B4DROvQnHZ2h73bP2RPl8U645CGZTgoRj/egtZnvQr67iEMQtNLxe4XMnZvPTx0XoT/oU8wPSLpnq3AD7z1lUbZjEukMLXyplNrRwPyhALkE1Tq3RqFwaPqDiqq/SD2dUE+nFEWJLsKECDqxLygN2HQHekYzbRpA0MaglQrdEcFoDQq8eLx3mbDdbs10cW7ujQ5Edt6jlMpEV7tdu2OEs8elaBF+nKdjWCgqX6NQ2uMljUHCxAuIeMCDUigKpMMObYuzM0iaPxUYqAjtK5SSPDARhVKBIZxzGNNyZbqTIpzXdvpSq0B1ltElzlEqSIFIBF31WV5YpKwKxDuaOrW3C7Mpjfc+NOMlToxCRcJ45/GA0grdmQitNB7BexfHr3fcu0O2eMQFIOF6kTQxmt0mfvd77PZ5t0vU7Gucp3Rt+FoDHudsniMRH8aiumyg4m+79WG3OVEU3QkJDSq8b8V0UZbtyszrWsWOtipHtTeYa6rL5eE+O9SKBG4vqj6DxUWGgwHoIPi8g6owcRWEla4E0EkVKEpT4Jsmti3UjWP/8pALG9soTGA6J3ilCGwSGEUpjTEG7yUwFwqtW+LPHhKZN3RZqSDG0wqVqIKTerqUSpHH4YnHVzI7mSu0o9Fa40UAn2milOkwgsyox13WV5xVlVsqjNFRnwN4mqYJ4lHrSKTMoxlzZN7IXCxxxNKyz654I+oqJVnGeIGy7LPv4EFMUeHFU0iNlykbG5bh0gKDxWVQp7D1FGWnmKKi0L2sBgSfSZqY8MLGGJTprLTQO5Gw6vEBp3inUFqjTJAY1js0OkoBieOWvBKDJon3izykaCWqdx3R3uEMNfd6qSNMzi5nzU2o9x6tVOinSkpUEBcWTqt24pTP3LLbt3ae0tyhFEW3E846iqJARTFprUWh0Mbs1Lu7srZiRl5cAm9Ip0P7Dh5mcXkFHyWXbjwbWxPKyrBn34GABZzLV6oIJ733CBalVR7UbFfmRHFsUcX++AhAAcRHQKoVhS4QEZyzmTlEiO/nR7vz0FqH/iqF2SEyOoRTak58dGHhpdgnSi0EY3R7VVQbCgVGhfZFonp8HEyXIUG7eBJ3FOm9tQ3GGLRW8URNUYROOmfjoM3M4NRusnLXXswzh8KLcPDwURZX9uAEtAjKOzanY5b27qXQCi8eHGitEmqYsS6Ml4hzvrZ+ZLZVCk1UHyoyiIB3gnc+qxkvgtY6MF+XoI9jVCilMMZE5or4JVswnX7u0CmXkilhprx3gEKbZJWlU+elgUIXBvGC834nPozjD2cmadKxQmOThXcBpJVl2dGN6cRwgzDQhHYjCJxfRY+nIKV96Q0GLK6ssLC0TFn18d7SjEfggyhcXFnBeeKkGcBFpZ64P3G2R9Az5NzRfFxdKk58Kz6DJEtiOJ2XO+nBEybV4/PkgupMSGdgidgy+9kYEyShF0QRJdS86N39FtKZJUVclJkRWtXIHFNIOscECyrdZ/dF3H6XYEKSqoUpTGeMkq2ScLOWQQLg0i3jCHFFxCYSk0iH+AAR7Ama/YcPc+Tyy/EiOBGa0Tbj0YjFpWVclATOOdx0m83tLVb2HcwDUqplAhQRYCWCzsHdaOVkYsW3WqusNsL1XXWTRHywblq/jMILOBzGFOiZFdiVALOf07sulnXOopQJUugSQi4B2QSCu5bIvJDJ6iNdq+b5REW+D9IxtKtQO1cQolqDQCSqEoVCdp694+IkdiT2wBStJPHOoZXJ53WpI0pz9IorOXT0KNZ5lDh8XeOsY3nPPpx48IISYbS5wfkzZ6h6FTOEjtaOVsx931molzSJkzj2nV+ThbELFtEKFTFPAnnB9LWIeIwpAtFnGLDt56WOoijnJqn9zfvAEMbExddRX7MIKqmBWRo/XttK6bBwJVh1Olou+f4RXHsJc6CMplBceiDtjVsp0n6eb7gFPXRW4/LKXq698UZ0VeGcRyvP6upFqrJkYXlP8CR6QeFYvXCe9QsXyItEg/JRE2buTwpltj+XIk4wK4ugo3VYLRIHoKJ5q+dM7ADMVBarIgI+WCXiPU4lL/C8Kf61HEHSJf9QkhABmyTp2OlI542a/ZL5ueuC+ixp5whkMNi4QIKDzkT3hMZoj5KAsYqknDMw6yIQdrPHZ8V0kCDxbBPMQ5GgYm685Rb2HjqMdS66rSdsrq2z78DBoE58YJTtzQ0unD1D0zSgQTzoiB8k2uQkD2OWQgLR+xnOI4vBWSkQgJsAhgBojTE4H67UWuO9w2TokvCGakGaIrQvAayKhOu13s0U7H6QHd8pJVk9JObQOjBoYsb52yhUvpV0+pTdBxEchLtGLKZVyxRJzaugegoA7xDv+PqvezL3Hn+Are1RWCziMdqQgx87Db4WZ8xanZLfB13d3kFJcIgdOHiUy668kqI/QIkwHY0hirC9hw4FxrKOzYvnWb1wkaaeYp3P7WpFa06q1hUsmdiq8zc3F935QGURI4D3YSDee4zW6AgQrRWcEPpoDN7ZTG9oF4fSwVJrGkGbIgLgaM5mQLgb0ogU7joSjaYwKl/QWkydMcyKwvjSVXnxgs5vSmnQKvui0AZtwue9K8vsWVnh8sMHOXr4EK6pOb+6xsrybZw+c44TjzzKtG4wZUWROyYtwElwI62cxBzzx0y/RXPdDddz9Q034MXjrGVzdZ3t7U32HzyEU+Ccx9uG1QsXOPXoozjvMEohKjjT0v1sVEnBdNbgJZqsbbtKtaJUzTBDOykt4lAt/JCAjax1eMA6izGafq9iOqmDWFUqT1YieMAAirp2oA0oyXobQHzQ0dpo2isT8AsN62i2iuoAyRnJMEvcdJeulOj2KUiGwCHBxDYobYLfSRcoo1haGPDkm27gisuOhMCf94BDUJRVj8sPHmI8nTLeGvFtL34B//D5u3n0zPk2iPb4x6yt25pU4TcR4cabb+Saa69GG8W0UWxvbKALzYGjl2F9UCWunvLg8eNMotgySgdfBVAWRdS3nuGgR3+wGMSicmHgO/o5q98T/pjl1iTppF2BQsflHxjeecFNGnplCQhN45LVGjBJV59KiNwurqywvbkRF5HCa42BzFjJy5rNRaOD4dkVctL5MCtqIgO1DJ2YQimdfTFKK9AGFaUfRqOLAq0NS4sLXHvF5dx07ZWUOon46ChUOoBrFaROv1dxw/XXcuzYcZ50040MBkPm4+hf+xH1uSk0N954E1deeQWLiwV1U3Pm9CqmLKgGA0Q8WgRb15x44EG2N7fQWqONxnsJg9Vh9EopFheX0YVhMpkGSSjg6IrQWRMNOqtnF4skBb1AAkRQYFSB1y77ZSCs+LppKIuCoiypm4bgIQ2WUMZfEqysg4eOsry4wubmBpsb6+goaZXWOOfwzmGKAlMUeAHxDvCorrmb+SJYharDOF3skiWF0qAiE2iF1gZlDKrQaBXeH9q/l9tuvZmDe1cCJhLfwWBtmy2SD/Q3aG656SZOPHKSK48cmmWMkAfRwRsZ2RG4PaKdqixZ2bPC1Dquve5aDuzbgzjHuTMbNE6xvLKCKMVkMmL1wioba2tsbW4GkFeYyFQBQ1S9irIsg9/fBJ3oRDhw6FAGVkm/5xF1xGyyVrqE7gyoJb7WaII6s67J9wnYKKpLoLYNKQiiIp7yXWygFY2t6fV77Dt0kGv7feq6Zu3iBc6dOct4PMbZBtcEx12BwztBotRz1kdPaMIILXN0+xx7Fs5LutMUaF0EtWE0ZVlx8MA+9q2ssHdlib3LS6wsLqLwqAi4Q3pCDFzO+3s6i0lHWlxz5eWsbWy1LvHMDDN4o42EBpEoDPt9nv7sZ7N28QIf//gn2bM05LKD+7mwscGe/YextsY6y/mzZ3jogQfxTrroDROdTFophsMB/X7FeFKjTUljLYXRONvQWEdpikA8Py8VUmRVZzzglURTVECSA12l6QWRIHmMot+rEO+Z1jaoDBFMUtfKRI0jNC7GZgS0UfioHpSHxeVFql5F01hWV1eZTC3DKO3Wzp7DNTUinmntKQtD45rYoyBxtCnQEvtvWiA9LxmDuoj4oSgpyh7GKK664gi33XwjS4N+ZCjJjA6tX0pJzNNIjCBpthOTGFAh8Lc+GvHo6XMce/BEKzF2c9ZAiH5GG5QbbryZJz7hFjyeVR+ieM46Tp0+w76Dh7PVsHr2DA8/9GAgeFQZiCRDirJXobWhir6Nqt9nvD2mKEuMMTTWMRlPKXu9GVdt+rBTQuz0xoiyKF8F6a8cygcii8B0WgOKfq8HgLMN1oXeO+9CrkaMM4hP2EoyJNBKUdcNDs3WxiZiHYVRNI1jurXFZDwKQC9OlHUueFzzpAveWbwEdaCFkICkums4MkW0NLQxLC0v8nW33siVV1xOpQ0q6cbEDpeYwy6p0q8ag1eglHBubZu77rmPC+dWGW+P6BcmRVc7ptS8KgH6/QHPeObTWVpaAt8wHY04f/48iGc0GnH0iivZWN9gUFZsb21x4sQJnAtqyXmXOV9cYJThwmJwFEVfgmssVX9AYxuksYjzOGwAdruPk9al3QGh0YehRfBUHDlYMizh+KkGSaa8RGZXQl3XCAEE96oKZXRQBQl6pDeS0hPjZItifW2N4dIyBmF7e4vtzU2MKRgsLbJ+8Tze26QIgtrUJg8lYBuFQiPeYcVTUFKURZ7g7iSKVwiWO7/pGzi8Z2+IOEe/R1awj+NoC3Ci1QgaxcR7zlxY5cFHT/PIiYeZjCcoL2jvEF1QZFdi98hWh1CWBd/09G9iuLSEApqmZn11nUOHDnPPV+6hPxxgRXC2yQMO9NTBASQqT2K/16ff7zNt6gDKbHAvi7PUtkEB1lqctzQ2pqfRVUUtGuvGEGYsEQkE80qYjj2VisTO3iDJ7mbnY5aXeHxdU1QlPlsArUMriWCJklirqA6959Rjj2KqkoW9e3G1YzzZzmbxDromzIRux4WglAkRbBX8QFkKRCxmTFDDH/3kZ3jOs7+J/SvLaJ/iG1EFsbtLgQiKiX4gJ8KXH36Er97/AKPNbbANznmUa7JrHCkofAKckm4s9MqSI0cv48jRoxw+cpimadhcWw8IV2sOX3ElDz50IrisI7VEAuoPVlEguIkJK0VRUlZVcCa54BxS2oCG2rrgmRRF4yz1dIJ3nqpXRtNYRTNLxxHGxBSlsgNMqYTYXeZrLYqLWw2bYzczSyKgfBbWaKXwXhAl1I2NKXvh9LIqaOomSDYFxUIPO5oAwonjx1hYXKLqL2Bry2SyjojQTMatTZ9UQ3LOpX8qzVj6Kpi4zjuUFBRVxXAwYGt9PWAkH0zNjY0N/uwvP8L+PXu57OghbrruGpYXh3HMWd9mVnEiXNzY5PSFi2ysb7K2ucXa+ibNZIJ3NkhCLzGwGPwwSEh3LEIyRySUUuzbu4dn33lnBkrjzS3G9YQ9e/eQXNDWWZy1c6zZ2u3WWspeRb/fY3FpmdF4QhHNNkXoSNOEjnjvcNZST0dMJw2DhUW8jpIEBfhov7fzm5B6Ruu6BZnzujTLCYlpd0C/32c8HgMe73VmmOSvyuDTOnxM1lEiNJMJhQDK01jLeDRmOh7H+waQ553NPgwVpVfbqdibzKcdgKkC3hDvMMB1113PytICd3/+C6yvb9C6mw3nL65xfm2dr9z/EHc85Unccv3V6EinBs2pCxd55Mw5Hn3sNFsb2+Bc8BeJB+8RH0x1j0TV6mexFEJBFEEiwt69e3na058RQIkXHjv5MIOFBfbu3Rcn0VI3NWVZxRxJieNs7yHicd6xf2UFTWASpULoWhuDtdMMUhHPaHMD8CwsLDLoC9Z7FheWQ3yko9K6cjlnZ+tWTSWn0rz8FkK2VlEUeBvOmEymnXhKcK5Z53DORcZrpQtKBXMWKJQOOaMC2nuayTgAQFNEw0JHUczOI6n4ZBikxuNPOjJQWZT0qpKzpx7lwN5bufraa7jrH+4KZj4avA3SURRWPP/nH7/APceO89TbngC64O5jx7lwdjV4ar1DiYtpBD46+pK6CJrC49v4UAdfFiKeQhc8+euewlXXXgtOuHj+HJPxiMuuvCpoee85f/4cJ088xNXXXsvyngp8uLlKcxxfvSjK6MRRpgBCwi1KhSBZPNG5htHmJsNBL4bvg+7tVRXTuqGqdO6kZAZsEXtSJTOSg/k5ieAPYppiEAllVeKczfdqXMBCVdVnOp22koOkdgSvCNldcZUliRDEr2+l1W6WQRyzxEXUptwFJjJlhXMSPKfisc6zuHc/p86eQ4lDm+hR1SG4mKQo0do7f+ECn/jMXUyitZUsuJTFnicnLTTfSbiKVA29aftdPO2Op3Ho6FG0Umyvr+O9Y3l5iT379mKtZW3tIqdPn2ZtbQ3nBO9DMEoiUk8rMmyAiepBBJTGOk9hTDjHWlzTMB5thxA9wmBhIWILT1mV2MZilM5mbaueunJAYsAw+TKI+QXdWUhmn+cpN+zhrnvX8RG/Kx0AtImBpuQ4s9bR1A1GRz+G+MRXkZC7B7nFS0J32aJIsZVI/cyjSZ1lqRQ3Tzlrg8fU2pATwZhTjz7K3n17ufHWmzlx4iQb6xshXY+Ao9psdo/WitHWdqaBJ4HROPHJLyVJMrQSou1i9FnFS4ojlx9lc3WDrc0tjlx2OCB6gVOnTnH6sUeY1hbrHD6aeSlp1+U0v/a79JeIorTBeouzjul0irMNw+EgJNpGf4UpDN4pnA2cbW1DHZN4BsNBlhmthzOCOmUic4Q/rTUWZiZPobnvxGaUJj5KhYrGNri40hNwDhcEca6Uiu7zkPJYTyeQGTSZ96kxmcU23bhKumeKl6SzRFBa8MQoLeRAm7eWiXXUTc14Y43FlSWuu/467r3nPsbbo9ahFy2qwIQRx3T83kqyOy1L3valyxTSjqdz6JMPPIjCc/Tyo4jSTKcTvnT3Fzh58iSTaRMSZKP3LBBNx11cYaEkYCeSspBCNpcQHEfNdMzW1ga2mTDo9wLXCzTWURRV9l5KHFfInXBYW7cSUFIOQ8JsKhghHVXSJty28yLAuE5rIazQaR11NKHBwN8xZhMv8pI2Fgl1U4dgSVqgaVmpFs8k1ZL+AgzuMEjytwRzCqV0TtT1zuG9RGdaEuyCOMtkPOX+48cZjcdcdsVlOQKtiJhEfI7BpLgIWbUJgfWihTSnNpI03h0QQXH1NdfgJNi3ja25/777GI1GOOewzlMWBSauTh8ztoVWT4V2fd4TKoBzgjhHPdqmsTWD/hBTFAEB62TbhD0YCRFLZDBnGyYbW5RVL4f/53FEMDN1hynSjLVHEutdUa5QceIUSoeJQDxlUeG8y4C6E1vLRM3MqYIk6qCKtDBTq/mynYfEJCEXlIB1EVuFcRdFifUuSyetFaXRbK6ts3///jSdnQUQxuOci2pRdZvK5+/SjR39a0kVwacTjxfF6TOnOPXYI9STGmNKnBdMobOLuF9VLC3tZzgc4iIDpHsnUZzUiJeG1YvnGA4GLCwsxQhlyHJ2tsmr30cigCDOM51OqacTesMBvV4fF+HQDJiLtFcBaETpMRuWT1aMdMGJgIoiziVVF3+o6zq5RyKRdM7LNNpgbdww3deoxuO9oHMWe4cQM8w5PyHhc9oUndB0yhwXBV4cRWFQSlEUBZPxhI21VdSw4fCRw9BhijThWmlECeKDm30mc7/l07kuyczrDHnj++LsufOceOghnHdxBem4YTdYE71qgcXhgOFwQBPBkfMSvGUEJOu84J3k/E2NjuHzksb5YJ8rhbU2OzG9hD0ck/EY6xxlWaAVLC4tIipEWSNXxM5GgiT7PzNEUieanZPRTpjgM2AOurlAJLTrojhPV6vEeAg27qlRSqEdpNxD6WStz9N/ltgB/O1fKdnYbqgjdlEojNExLJDEv477R4IVBYAXtra38HErwIzrW2iDZclk962EBNqA6AzOkO4tZt/F64rNzS3G4wnGFBRxK4HSsLwYoodaacqqRzEYMt3cCECUFmBKXIHOe6y32SYuyx6ekPUc9lb6DFKttdSTCZPJlJU9K2HFoigKHcCeg4XFxeyVS27uNAFJfcxgjBm81xJouae4WAva64wRFGC0oFVBSuIRVIQewedho2TTkSC2sfipQ4zOqjACno4qmWGN1JvQHg6NJwVtBMHaIMG00VRlFRxq0WuslUZMyO0QD5PGznCggllubMUd0DqttEl4itxuC5SJgqvFVMly0QEEFXlTUW9QcWD/PqqyxGiD1gWiDJO6CVjES2cT8Czo8j5aKyqtNJVVTkhe8YzHE7a2twBhaWmRJppqCbs4H8DuaHs7rKJkNcwpRZWkRqtxZ+dFBd391Nv2M6hMiLASRHdZlHgfa34URXSYRUoJNE2TJUjOxOpM9Q6JvMuR8Y0IXgnnNzxTV87igAhGvfPUtcWYAmUMZVWF9pyPKdGK7e3tuDguDRjbI9TESBu2A+PvvGan+m2PwlobLQXHcGFIf9BHFyUGBcbgnDBtGqxt8kYcF8Fm0gviow/D++h3j+lyEibdWwsijLa2oNAMF5bw1iJKY+LmpaIsQnRVgqnlncvtpYlReQC7EKa11NrBKsVdX91gUluUGESFTHHrgkrTSoVx4Rn2+zjvg5MoqikfUwtS+mFi3sBy84p5Xpm0h5aAIZSyCDqbtCoyo4gCr2hqC0phXSit4OKeXaU0dT0fgth5tOCx7Yvu+FRmmTJdIzPvk6oqXNOwuLTIYDjAe6Gs+tQ+hMdtHXzqk8mYySg4UPbu34vgwq7qOBnWhUCYd0n0B4sD7anH07QRgF6/F9SJc9mRROx4Yy0iirqpcU0AUZkpvM9ToUkLO0qRaL+3smMWqK6PLCIpAKdiRDX8FlRieD+aTjFa06/KuO/E0zhaDEA0YztMkV7DrbvMGrczJrO3q9+ztziYk62ZnKy8IEXEhHyJas+QZrNmMtrKsx+y5metiHDMW2cRoOrgRU6ZaF3V0c3h6L4vmqamN1xAlKE37GGjCTWdThHv2FxfwxjFcDikqMqY5i/RZyFZUjjXSg3nha2tdaqioihDcmryV4SwdigVJCIZpQth/0dT14y2tiOjxohfmgC6qywSWaXwVUuQbmyldSW0WxULYwK4y+Ufwr2ccxSmoGnqPP2DXj+kAjiHw6N7BTJOZZ12NQZnxXJ0jiivWFpQrI/J0kJF93aSON3LvHVoHOPNTUp6TKfTGSzTnrsD9na+U6SkFtWhhfedpOXd7Wq09y6oBgV1bamdZTIZsXbxPKvnzzIY9BgMBgyXVkKIXHxMlXeZCGECW5e4QtEfDCiqHloXwcLQJnj5FB0rQLJvwTU10/GIZjJmaWmJ/mAQzeLkQwjjbBOKJLefANPMAorSJKmeZGWIhIyqBBpV50+AyXSKiMqSpJ5OgzVFWHmqNAka7MQcux0CoDHK8fW3HmnP7npE9XzSUVoMBmN1rmz0eEnPOxu9NBbJFswcU3Q/ax8Bl7MW7y2jzU3Onz5FVVas7NuHEoU2FZPGUZS9oDK8tGHaKKKcb6UHeDSasgxMobWhKssgHaTV1d4Hx854e5vx9gitNcOlJbw4mnoakmvSBuMZDZGwh89/SJbCmcAKFQFbUCEhXV4lF0KYF08YS/oTid7EFvBmq0eB1E1uY8d07GaZxNOs0nzi848SIqTBiVZWZTgr5nsoJZSR8Vr1okBpJNcI2b3tSx6XkAgpjNA1HrqXFM55XGMRGrbrKc5a9h3YH0ClaEzZw0bMYFRwRIWL2xWbXeE+YA1jNKZod4ZrrQN2cCHg42xw3462t2hsQ1X1GSwMkZiwUhQlyrQWDTInsmeERlqBu9AEEBWwkIpqQySE/xGXxauPyUbJfxGypoq4SnXMX4gCOVes6cqLACC7gbwkgdpuKYSWHrow2MYS6pCEDVBFUWJjzKgoS2xdx11zbZWcx5cW/5Qk2Xl0zdRu2KGwTcOWXUcBg/6AhaUlMEXw7inN1Nro0AqZSf2qzIAxLCrp4AsX1UTYV+FUqA8RnDWCbWrq6RQT/QRF1aPqD+LseIrCYIxmPB6xsrw3SIOIZdJUJMvE+xgvjXpARGZ4IzHU9fsHnF6fsj6ROPnRFZ5C3woQl30HSfe2+jhFVqXDkEkSdLBMZ166uKW1WLLHKdJMUBQgQmODaW9tm4Fmm2AdoQXdN8HtPUOF3Y8Zx9qO7+bPbX9I5rXE7wvvPf2FIf3eEOeCm7dpbNDFOJx1jMdbbGxtcvjwEWyOJ8RAjQecR5zHJwwS6eEi80ynY2zT4BHKqgcKjO5RGJM9HcaUpAQShTAdjymriuRbAIVOuqKDPdpjli1SYO7EhSmNi9GpCHqNLii0Dr4LrZnUkckJ2w7Fe8qqwvlJB7Hr0G7sQmSVKI12o3xGvSS1ZER3qp6qbFl1d5eFijk+mtUNWgy+CZ7WnHZIx9rp8EkHfu+gx+Md3eTjpCV12A2mAwebgsaHSnniwu6xzfU1FHBg/0Gaug4MMefgct5lrCESMYezTLY3WV+/iHeWoiqpej3KoqQqq2wFpMAUGRAFhmualJwaOVsSvOzgjcSBl1oSZNgwc7q1lsZaJrahsQ1FEfau9ns90na1yWQSzTqyJzVprixyM1CcP6TzHxCFaLju6ALDQuXcysIotIayNJRpI5bziFdYEfqDxcAM0T80O65LZIoBsyyy+0nz/ot56VH4WI2uthYTie9tMFaltAAAACAASURBVFOdbVjeuwelFP3BQtwsFG7guzmCCWckh5QXtrY2g2paXCDVswph7yllZBLnmljII0iB5EgK90+paGkQrThO4m73yoCzA08Wi+qsRiRmK3mw4lAOLA6jNUtLS4zGY4qyYjKZhEQjEUQJjYvF4GJZKDXXXnez0I7+IEymdbDa4p5Ha4O/JiTqKHpV2Ic6bRq8hBRECLEn7z0UKltayZojSq8k8dr2mBEc8z6L3RikS8uiaZpgrjrPdDyK1XIVi0uL0TGiQBlEa7ZHWwwXFlGamBoX3eDWxX0iLquYsteHogRlYhYXMQdB4V2D1SFeMih6UBhERb+IcyFAp4iMFgNuElUYrdkpOWX5Eit3RrgEx1pe7dkH0u5tdeLZ3N4ODrcmeCFdjv/EKa8MMnVpJ9YOoicpkicudkSL5uGLwdUeIsNqZnxI3OWvPEVRQMw/lRigFJUN8ogHOpPudxn7Dhpc2meRGKJLK+2sY31tlc31VfCWXq9Hvz+MDKFzWaHR1kbIgPYhKtqKsmimusAY3gWLoypL+kVBqYNuVl7Q4miwMNA45ShUzNuMwGs6mTKeTGkmU1zT5GzmBCxVh/vpqpkZplAzfzcdXeDwnh6kgiVC3IE2u20vl4JOZmFEk8YYUvaY6Rf09i+glYBq81Fyy7mD3XkRkq0bFngMosUd9wlcpxR+EY9tXJTCcf+p+BjLiQtaUhej37Qz5CxNE5DsTHz7ds5EFcnETexRICEzWStFbzAgZTsVpojJK5GrY7QxlUBMOZEpoObjrva0WrqdF0KUzzXgtif48ZR+r0dRDbBRUlkbUgi10qEorCli5pgEHZ0HEv7CWGKcYWYyZtHY6bUxTSMoifXBlMpZ4sktlsaVGMXESrsigo1AHICpZXp6A49BR9/DbvXABbJ6nPfIahUxRtY6KjJ9G9MQ5UP+SqRxb89CSOqxs5lhMnf/eLtWyXUmvNuH+b6298ofwoYjpTX9wRARYqZVDDQRVpBtGrY21+n3+wwXlogAPev/tKrFpzTAGPbtNJ0GvThYxJcaLTCdTgPI9Ja6tqEAa2Uw1QLamDjpc0E0um2aztB2P9bH0eRNuhiyni7LEHZPDGmKgrpucj5lmtx8DRLyMHzYRK3ZyRTzkyCQswCThzVRRaXJi5ZQvi4XYQn4ptnaJlQlrlJXHvfI3e72f/cOdsVwljACYYtioQ3NNG7Rc0mMheLltq4Zj8cMFpdYWFgMxAkFH6LobKOgrouUffJIxuxsE6wOp6AZT4I+dZ7Ghozt3qAXiqfogqYaIoXGT8OuL9IC61gBSlQwE1ULMDsjbokUH2+h0iR1sIBWGucti4M+k9riY3nKwBdBrwcPocE6l6v5OSXoSPgcCM9mbcfRlYFJ0roJgyi0gGgdmMYTkpPivbSOFor3gWkseAW6pIOJEqO3iQdCy1y5C12AnmZ9FjWHvqlZAFuID5t8jDY4a3HeUU/CZl+PoJVhaWVPTIeTWA454IzEJAljqOjkSivaOYePkVhrmwgsU2qfYIqK4WAPVkI1W2dKVL+g3FiHsUfKIk7sTuQc8kx1LH1w6VWUrdmIZbx4ChP2s06bBqU0W+MJSmn6vZK6mYaEJVE50Obi/g/xgugwqV6Bme9Xp812ZiQz9MDAFQcq7j87xWuFVmGzs/MuuqfnTeCQ0qB0m3c4m8GVFsROa0jUDPIOL+z8nJk69VMyY4R6WR7HdDJBG0NvOAj1G5QK1d0EpJmiB4MYDW1NywySYqAHJ+CFummoGwtaYZsGJVCWBf3BAsoYvDY4D7KyiJQVvuzh7Rg/GVEM+1SmgK3tGbMzj6s7mM4AL8EaJKlD9EmEPaJEaeNDTqp4RpMQwYxBakxh4rYGCXGMlRLRmulGjXZqZ0HWXfBG51fGTnjwXI1IgKC9XsW0nkL0k2Q/egKUEe+4zGlzqX072utYHkmaQpsRMDf5ao4pJDMxFI2zTEbblGVJf9APFduKMru2kVAYLakWpVQunZh4O4FPI6Hir3TMPGNKEEdZVFANaIzBlCVoRblvLxNpkO0RUo8olpcYrBxlfPIkdjzBCFkFtAyR/oV9InmIEe904x0AVx+p2B55zq7bTIxkTaXXlOPRitPA9DaBwfi/3mxA6ZB4g88YYwbAqR1ZIZ1JAIcnPSoj+CnSvhgVgtBxa0HIbgiu81B8LagRFROQVffG2cKCkPXmyLv1SepE8jhm6KBa+iVvLkSJUfX74VEMJvjuxYVgmkKjYpFSG2tSJTdsJoZvGUMndaMEVSqacagqU1YlgsYZRW//XlRVoLViPNmE3oDBlUeDt3Vzm9GJh+nVNThHq8F3Qf5xUlsm2F1mrG02wSUgLUNn01EFfZ4Cf66zenwHpWujQ2UgD6bUQYpcQjp0fRkzExiZVosOqkmZWDo09D2kNIYxGVPE0pwxuSZGY2OifWR+nQbQeo8hZr4FxguJFzazRNe3kv9ngZosnKhKko2dIqHOWkQ3FEYzGk3p9Ye52JhP0UYFEkso5cCZ83gdLACDwk4bTNSR9WiMVD0Ghy/DVUVkqAZT9ZH1Deoz59HOgxcq50OtDaAo0sNYZt3BIU7i24EqdQm2gNXtyDy6rcCrY9oeRDUo7U6wRDSdSizjUKnqigRs1dpHHQboMEoyI5VqpVg6Lj9QcvL8NEilDCVUK9aRzr7aMJ0SJxWlML2KsihZXFxg78oye/eshCz+wYBhr+LC2hqnz51ndWOL1dV1RlubsfZF211FrjwSmaGtYpgoXOiU4RPzFKyzbG+OGA4HlGUP13jq6Zjt7RHDpRWiUIneQBW3AYTNOk5s5HiDm9qg3CRIIlUWlMMh07V1ZGMT0ziUE3pVD6UNjuCytm4S9lagcKmSTVzJGWIlczV+0+LyXQ4J9aiSvyMxgdIhXyRV50OEQb/HeDxtYyOi8oSH4FoLJJOF4XdpuM0W64j4dBmdYJzvnJsYKLh80drE4rQhW0wVBSvLi7zoec9leXlpliYqTbFi7/Iy1199daCNUnzlnnv5+Kc+1elcdNomKJLkSfYFhO8L70OpoQRCyrJieTGoj8l0grcW7yxlr8xFyGHWa5ZT/OOfMgZcjaJ99INpGqYPnEBbj9ElWvfQPYVrGiA4kaZNE6ryilBWZVYlGWdKq6tTH7IqUXP7RzMdLCLB5a4xGYCK81iiLg5Iicm0juUWwxYCZ0O+6AwAjo6tf9qbsBsYVZy9GBKC21sEhqiqKiZLpei0BEvOB4wh1lEVBSuLC+T0sqgAiJUCRMPG9jYnH3mMC2urnDt3gQsXVzuMmrnhnzyK5LMwMZvbOheKgQCNd5RaU/b6AYfEh6goUpxCWsaIO+CRuDsKj9IFYqAsKxBHJQbTXwDA+5BHWTc1tonVXZSmqEqGVUVT1yHQJR3Q1EF1LcDu6M+oM7sT4jFoifs0oh6tyoKp1NAxQ1sQFrYSNE1YqVoAHQq5jUbb5PlUswx4ySPjHwVKcNhIuxKtPL1ej2ldx4qFhl6/T1PXND74h9I+KvExGt1Rd17g7PkLnF9d5fzaKhfPr7G6th4lQipM49s+dLrSZsXNjqEDPiXuUw1maGNrwpMFDWXVoxwM0NWAqbf0vaetEBxevXNsbWwgTY32PaqqCkKt0PHxBppSaVQVH5Tj24Lzk+kUpTRFv4cuCqQocOKZTEYsLy+zubkxI97YdQjpk3RQdnvsH2p0oTm3WYdV5cNWyLQRKqTmN7E0A6RQv1bxAX0aysJQ15NQajr+HqS+mpUm8ZjHGzP+BQlpDskzPJlEc5Vg4jc5v1RhSpMXDUpxcW2dz3/1PkTg4uoaj5w6FQvMxft6hUgsbBuldzIYZtIjOwwy8x0p+AeFKKhdja1DZrQqSqoDB6CsUFWFE8FWFd41+PEYPW6i8yTc3cdAV1NP0M6GultKoVSJMiVGGZrpFEVFYwVhiioUmJJy3350vwwMEXMulQFtG+rJBOV8ZuouNEx4VHQCgnlKmH+ozajx9BK0SiBVqbjvxSE+mOBGK0od6mWEcLjC+wB+G5uy1ULsQhvT7tVAMd+LRPXQ95Cc1MQsb4m1xDQSVICSfF7yQyhSDRLi6g5iwznLZ/7x84i1+OjAakFraLGNKbX+ilyfNFt5bYe71GohtVA422CbKRqom4bhgYMUe/eGHWK9kt7iIgd7BZcXJVU0IVGwdtl+Pvapv8vcGpdD2FKnFGJDba2xj7PoHeWBA4jpUSz0UL2AM+x4lbqZUJR9yn170KpHc/EidjSmmLE20sDaz0E1pLa7lkJ7TBvP1IXSRHc+7XY+/pm7SDGMLmGtk6i7o+fWSt724C87iD9yEHEhIUndc2+A9X62xVZSRDf5cIA/ehhZXqHZ2mxjLxIkp3n40Rn6pSc0aqUiHT3u8OFQ3UAJ1doaylu8rZE8ha1qaR1XMZ3AFLjBIJDGE40BMNubzPHHjqMwhcE2DTrmQVoP5eKASheM1ja5WcP73vjjLC0Md73Bl+49zht+4W187JOfSbwRRJ9PzzIDlEJXJYtHL8OKQlxNMx7jKkux7yCLw0Vke5tmYx179gGMBymL4FCTNOnpUBl35OJniTS7jFKURuN519t+jpc8705+4s1v4W3v/OO8shKjJZQfwXwguve4yw4x/v23IAtDaCxYy7RxmA/9Lf13/j+oM+daaZx9GIEppv/xh/BHDjO1LuRXzL0Wn/8iww/9dX6EWKKdBdzVVzF9xjMRrQPDOk89mTL86j3o48c7MqmNkLQxk0C/8S1PwPcHnQx4T/Xwg7B1CW7oHNpZD7bdM6pKQ3PqHPWxB1hYW+VnfuCVl2QKgCfdfD0f+J1f4rYn3NhBvnEFEP0GBGfM9voqbryOVIbBkSNUi0u4i+cZf/lupsfupTh9GkyBXH451Q3X4iR5IqNl0l2f7WwkdiGJ4qgv8p8oxZ7lJQCWFxeyGtAquJwRiZV8432jWx8EOXoQWVzYMW733DsZveWN+GuumhHHSYzb596Jv+KyxyW+ffITsfsPBOyTtLPW2JtvYvKc5yBlOXO+lCXbT3oi9RWXExjCp0IRJEMABF8UjJ/wRPxwtt/VyYcwF88Heip2uPQ7si/0SEqN6ZUsDYaUm1sM6pqe0ijbOmG+euwhbnvhv+WaO/81137zy7nyG1/AD77+Zzj52BkA3vXWN5OCahmHxdWjo/oxS0O80dQXz7N97KvYRx9BN5ZicQmztEIzHCLeMj12P6PPfQUTH1ovMXFztlJwJxEl61Whqir6g0F3puhWQlFRVKf9KikrPPlMRCRuAArnm7u+SPUrv0X123+E+dyXZidqYcj4TW+AQwdm6StC+f6/ovi7f5in/MzR+4sPY86dA0KE26hgPNdPu+Nxr6uf+CR8YdKWsiwRBMEbw+RJT97JFCcewFw4t8Nj22GrmSM8r8SEgNZwcYlpUzPZGjGta6pBP9/oLz/5D2yNJzE1DdY2tviD932Qa6++ite/5tVcedmR3EQ3F9FUBRQFVQH1o49S7j9I/9ARmFompx6lOXMyPD81ZouZQodHdhcG8ZYuqu/uA02WAXODMlrT7/WYTCbEi6hmAGkSq+G+SW0kK8O38Kz17fzRn7Ygb+8y41/4r/irLg/nDAc03/Eyqrf87xkrBaD/++/Bvf2PGC4tUhVVyIMtFQf29jhxbooibOae1jXiYDDoMT10AKmqtlw1oNfWkP4ASU+mLkvc4cOUD5+MI4qAtSiY3HY7fjiMeCkyxUMPUFw836rdGebYicuEsPWalf0HKUzJxXNn2BqNkX4fvXcPsmcFKdonVzgfPJtJJAiKT332c/n3Z99xe1y9gchL+5b4tZ/+cT72nt/k7Gc+xImPvJc//en/mzv3LLB+9+dx58/T7/WpFhbpLyxS9gc862nfwPt+6xe576Pv5cxdH+Kuv/h93vkr/5UrLzvUOsajdFDR4fasb3wKH3zHr/LoP36Ys3f/LZ9+/9t519vezNWXH0UBN13Rnxn4bU+8iXf/xs/z6D9+iI17P8Wn/uwd/MTrvicm6JAfiaVVSj0kRQ5gfYvBj/131PYo388+51nQVTfJ2RZ5pJnW1PUUgHHjefR8rA+K5IRgEKzzIWjWOYpHHmH4tx9l8LGPo8+fp1xdw1w4H8iggjpReKQwTG7/evzi4sz11YPHKC6cDd0SOnuvW5t11h0OoEKiztojJzESipHopUXk4MGog1yGNkpLK7I6K/AV3/aC/P7ur96fBfyznv5U3vVrb2K5g0+WhwOe+ZQn8sy3/Cx/9dFP8x9++ldY39yKk6z46R/9Pr7vO146M7Arjh7iiqOHeMZTb+PHf/Z/8gd//IH8mwi8+Q0/zA9+17+euebyI4e4/MghXvzcZ/NDb3gjH/jzv8i/veRbv5k3/PD3zpz/5Ftu4Mm33MBLnncnL/yu17GxsdnBS60rHSE4nLa2KT7yMZqX/PN8D/eEmzGfvYv5w994PY3WNLTmpROB8Rh99lz22mqjY0mGOcbY2KCnBLe1gbv7CyxaYbK5jijP3v0HUEXBtHFcuOlm/GAwk6TcO34/5vxZ5iVC92htudlzigC4HCgTkkeGfZrpNkVZUgz7mCIAoCsOH+JpT3li0PVK2Ls44Nl3PIUXP/fZAHzys59nfXOLqj9geWmBd/3qG1leGLKxucVb3/EePvH3n2Pfnr285tX/hmd8w5N5wbc8nR89dZb/8su/BQg/8KqXZqZ45NRZ3v2Bj/Dwo6d50k3X8f2vfBnLiwv8wk/9Bz7x6X/IuOaHvvvlmSk2Nrd56zvezZfuPc6/evHz+NZn3cHy0iKvfNmLedeftozx5FtuyP394N98grWNTV7y3Gfzkuc9myffcgM/+brv5Sfe9KtZxQTKzUVwBcyn/3GGMfw1V2I+e1drlYgw/e5vxz719h3WSHrtfeAv6X3lns5WCcE8dgq1tYUMwoLy3uenJEyf81z8hYv0P/sZjLNUwyX6+/Zzds8eXMIc8Rg89ACcO9MBmJ2ibvOAAmYUiiI/2z2UQgyFNRymVLh6jNvexNU1AC9//jfz8ud/865c98m//zw/8Pqfpd/v0+v3+bnXv5blpSBaX/Cq1/LF+46DQGkMH/7op/mZn3gtP/CdL+P7XvFS3vXRv+PLDz/Gf/r+VwHw5Qce5tu+5z8xntZMxxMU8K73f5g/+53/wfLSIj//n/8jr/ih1yMi/MRr/x0AX7r3GC/57h/hwuoaWmn+7nNf4ejBPbz4uXfyxXvu39Hf//XO9/JTP/82vHcUxvDe93+It77pDbzipS/gNa9+OW/7vfdy4tFTABhdxJBBqKWxG1CbIXA0WZuXvhD7TU8NTHCJY/qi52NOPIza2GyfGClC79OfYfKcfxYmSaVAXIjwNnv34L/+Gxh+5tNMxiM29l7PtCxnmOJKhP0HDvLAxYvBGZbSLDMLzL8Ln7pj0wqFAUyvRPf6mMZSln2KaohYj5tOH4cM8HNvfTsv+q4f5uFHHuOmW2/h4MFDPOsbvw6AP/zTv+Due45lq0IAvbTCT7/nz9kYB3D4jG99Dk9//vNYHgZL4kd+8TdZW99gOplkDv7Svcf5zT/4EwDufNrXA/CsO27PzPeGN/8a6xtbAYCJo7ENd3/1ft7867/DB//64zMu6i/ec4yfePOvhf0wTqhjfOj1b/yf+Zynft0tLC8MGPSqWIE3+jYlw+tZTAGo0Wjmc/nXH0M/8tjj0q73Fx/CbGy2lfai17N46AS9T34KlRKTYQbUun378ItL1NMJhy5cZOhnme8UChufCYPEMteQX3OfZ0cw86kQrZCqwvf6mKWF4If/whfQ3mGKXs5S+uXffhf/43//IcHTL3z6T36bqy4/wtWXHwkdB7anoapvsFDglS97Ea982Yselzi3XX4Atb2eP3/xs/+IQtHr9RjHYB4o/s/ffwF+8LtYXlrkqsuPctutN+ZrPtkBwApYXV1tmWHOdP7EZ+6KKQMhLSCtktX1TU4+dporLzvCLTdcx//7Vx/rbF/opDL68MA7d9uts2R98GRsJra7PWLwK7+BPXo4PlaTbAkt92Hz4hhOn0aUyo8LD3GKkONZ3n+M8uQjeGPi77N0aw4donr4Yfx4xPXnL3Bs7x7GsbCtBb6kFIP9B9GnH4tPon48Obfz0GIUZmnIZDRi++FHGT/2GMOyz9LSPhYWFuOKoSWyBO79wz/5cwBe8W0v5KrIHL4zAV/LsbE94i/f90E2TpzI36VnDE6zpAqNLi+3K/Tqy4+yvtG67+b9JrN5kcwQNV+X8islOuBQnHjkdLyf5CqDyVmWk24AvzTEPu/OtonRGPPle3aMT41HmGPHMccfxDzwEObBE5iHHmD5zEnU6VMxEyvqdxWYwi8tM739KUyf8hTqm2+GxcXQn717dtzfe890PKEZjbjyzBn6c48KGV99DfbAwTbQt+MOlz4KaSyT8xeDqNFgTAU6PFRGoWNaO5kwCaS89ffew2v/7bezvLTIT/3I9/L9P/Yz0VT1fPKzn+NZd9zOF++5n2966atD6JpQ88EsDNG1RZcm19G++bqrc4f+/Stexm/94Z+0FXvCTPEd//L5LcGBuzvY4Ye+++X8xjv/uOPxjK8R8V95oNxJFiFko0WHFrSZVorgD8F7jFb5EV1KK/xwgfqX/3twkUf8YP6/T+5C2m7ppK7HVnF61cU6X+E3lQisNfR71F9/e/BjOE9z802oySS4tju+DZoGbx2T8QgXs9kObY04fcUV1B0Xw/Ta60GguHA24ug2pNCl1k4HV+dHUKjCUFxxDcW+PchwCRaCXZxXjwo6dn1ji19/+7v5yR/597zipS/gTW/5nVDWoNfjAx/5GM+643aefMuN/NbP/Wd+8PU/ExhPhD1VxZXXXsWXjz8cjCHgy/c+yJfve4An3nQdP/aDr+KRU2f487/9VARMwutf89288J89o51TEe7+6v186Z5jPOmWG3jD676H9c1N/uB9wfpYWV7iNa/+N7zhdd/D2975x/y3n/+V1v+bVn5ng3baIZYdW3G8aWuF/ZZn4G+8Dnf91fjbbkWqHsTVqc5doHrPn830LU/Kq19xSatEjUYMfv89qDNnEBFKEwqoyMYak63tYHoSnFlizCxTQAgfeEcznc5YFPuOH+PC1dfQVFXbj2uuQyHByTWvky5xFLN+L8GvLDM+ehWqVGjrYtmhmPDbscUBfv3t7+F1/+4VLC8t8IYf/l5+/vfeh7OWt77jvbzkW7+ZZ99xO6982Qu5847b+cRn72LPygrPuuMpLC8u8NzvfC1fvv+hMCkIP/Lffom/+aO3sry4wNt/6b9w8rEznHzsDE+65XqWd4lVAPzQG97EJ/70d1leWuBtb/pJ3vC67+HEI6e47dYbWV4KDH31ZUeoXVtGOZmdaZNUUcTKwDptrwvSQnys/nPj9Ux+8T8T4++BIZpYZnF7RP+Nv4raHnWgTKBO/S9f8LhWifR6jL/z5Qx+9/cxG5tYJ1gJOTH9T3yc0T9//q7XAZQPPYiup7HqYIhiB7eDgLWsHLufteuux1a9fM3kquvoiaAvnpuZ8U6PZj7pGceGgHGgLp7FHLsfvvQ5Nk4Hr9n2aJydJ4np1jc2+F/vfC8AGxtbnDh2nJMPPoggfPtrfpy3/t57ALjy8iN858texIue88x2kkVQ4kJNT/F86Z5jvOz7f4xHToX2rrzsMM946m35/C/fezx3c31zC0T44j3385JX/wgnHzsdrzkSrZXAFJ/87Od4/Rt/NUseyM7v8C6Gt6HdQglwcX0jEF1mXIX5UNsjir/5BMPv+b/QDz4cgN0crYuPfPSftErKYw+g1zciOeImLgH92GmGH/owant7xzXVffdQfeXLELPlnHXh8aBNg3UW6yx+WrN4370U62sz106vuha39yBdJsixkvhVVsSLNz9jJo3ZmALT79PXChHF8vIS3/6S5/Ibf/A+wlacYJVsb67jnaOqerzq5f+C9//VR9kYjxHnQjnEeM/bnnAj/+K5d3LbrTehtOLL9z3Au9//YR45dRabEnu0jr4UYWVxyDOf+nU88abreNLN1/Gle4/zyb//PJ/6hy/wo9//KlbX1nnb774bVZj8EJo9S4s8647bedItN3DbrTdy91fv54tfvZ8P/vXHI5YQnnzrTbz4eXfy1ne8h/WNrVBqgPjkIxVUx21PuImXPO9O3vZ772F9czvvSLff8nT8TdfD2gbqvuMUd38lPGHJdR4nFUX9TPbWcEjzLc+MvCU59L3cU2xe3Kb8TPCUhrLObcZVmjCUwh0+jDt4EL26il5do3QObwXvm4CBiio8xlvFtiPO8oSUS2s0dnEJqn5ONSjOn0G5eUnWMstCf4havOXpAq0dXRQVZdnHlApEhwwj6fwRcpa2N8IjuXtVD1NWofZ2ER6V2dQhZS8dCV+YsqQowvbA4AJ2ocyALoKNrcKT/yQ+x6uNN4RON02Dq0OScZcxUt931Z8CWoW8je7PKYUv7TVNe0IFiY/Uos0FFYnPoo/FYZRCGQ22lURiUxXfWYsofBfSHNNYBqVh1Fgy3aPVo43OgLmbL6Ig1B91NXqlh9sWsC7XClepmG6WhmnogrfhceVJ0/gc+GnHP69GFvpDirZzsQhZTK4J6Y5z1m8nfpCbV90fsweI9kEv7SrQxqCKIqTiK9C9HpgKKSp8tBDENjDaol9pbD3FzTePyuK9mxibE13mDtHCrUf7fOX0hG4CgkoPtiPsIen3yoB3tKauHc57vJFYl6xdidnK7bQ/016cWJJfQs2e55Vm3DjavfIBCHvvcY2LeajhCq1CyoLznsZZxIPbqFG6jHf0+NpRDouwIUrJLBFU20+BEAvrWiQq3KOlr0oWPEW7A4nsFFWE55yGqrymbSX7/XYDLx3DJ+UxKkFJePy0KnuowQKqF8PHWiPiUHaCsyNMUVHoAhkMsNNJeLJQ6v3XiKR3O5TXDfsTxwAAIABJREFUXNi2KK+jLo1jjD4EpcA5z2jc+k1CsRShjI/wDhX7QtFY31nRyfn2eB6C1qUdDhPzPtKjcID4xIG4yUmp3E8f0yKlQ4O0hbE7A866zv4UZnrVFQhfq0WCCIVEHUzCWRIyv5vJGJSm1x/QdfB05Hu6x9wbwlOEjUYR6llqXUBZIVUZ0uIJu+v1YIChj7EN4iSUYJpuooCq16OOD7fNg5ybh9axNTuoGSebtpzdLHAqFJpPot6kstHpsvxG4eLjIkK6fjgGg0F4esJkmnNEUp92sIbM0mfWR6gBF3bqq07ibrpHUomSGHc2x8M5BzpsyOpCyFDqodtO6kby0exWf2uWVJ2neVEoJBZukXZ02tAbLKKLAq9NKDySnvIjMy+7vhc0uuoH51B6MqB4yl6FKYv8+Ao/HWGJTwQ0BqWKWOd7E7GWpN7+Sc9dp+vznlflDWiP8gV5L0wkcLvLLK7ISJj87NTOvUajSdb7SqfNHpGal/D2dlVcV/MfWelxenWSNwaGDc3xwb/xXj5uag674nzyphNqwyV1EHV+2K6/65z4JF3y2Nr+doVxmzobvijSHbQu0GWJXlhA9wZ4U6J6Vah/Ma0xo3WkjjW4E9HpoI154kh4aK2oFLUFOx5RT6DqD0MijFG4Juxat80Y5SxST0PRlTw0mWsPYPeJ2O0Q5aMH14GouEHZR6KFnfwdGBRXasj/bANY5EQdpWB42YDxxWm2RB6n9dmVHSf17HoT6NKhWdgo3YLXdhefCntxmEF2oahLopKkJ7Spllw7pqO7emZ/aSVW0kVCocsq1M4K1VBRg2WkrFBiaaZjNAWioBSo8z0kEyw3KP9/aV/3I0mO3PeLILOqe2Z2ZnV7urV0lgHJhiQYtv//d7/oRYKedDBOEHQ4AdIddvZmprvrIzPJ8EN8kMzK6tmzcxfTVVn5QQaDEb8IBiOCh+196jTy3dxIBD4eQUU0QnydQWsBk0oTIgZbUCzE6v91OhPR5D+GLQB4Oiax6gdF36VSoiK2ow4UFehe1zaziABUgMA4f7lAlpaXdCeqtjt63QdN6EqrDWrL7uOZdtp+Fd2tJ3be2+DpIFs8jj+7wsth3BLIxoYInUuna98tjOPD23dYbBca2c2VYDW/WC3iMmMlRKXhHeq3T6IRyCBAkkZoUxXQPGP99An15Rm0zJgqKc5AApAt2XvVvRsVVjssxdP/aIbojjfHZpbFYlWXolFcSlikuHpE+/xePtsEFQU4OTBvKu71pCkdzWgFhBELSBhBYbCjr6iKB0FrlBtIIjNBWJC2EQrU9vr6c4PpHaD9BCISCDyfTsg56WxlIGHFRAWHQ1IbuQrkOgOLtJkhikl8XwPId6V38y4nlOsCqlVDARMHRK6WlEVKbXiDEipIg4Btt7vn1wxC7RH6a52kgr/8T290hgrFJmH9jSFMQAIqkSabp6SFhEs1oKiMM022MCVaV8UEyOsM6xJ1OBhEBYI0FPtrO8jcktFBzbbJmoCQTom7HXcbjStA7L1S+aGs5vXd4c+BYKTjKDGzZuHX3FQkjNmjiaQ6nsVBKpa6aIpBjPpq8I90AKbMCzIzqpByelFmCa4lQ1LQwFsAmsEnMerljJxISzHEs3dSHdzRp8MlkvB/fnve17HWx0wJyaodUGKUxRPNu2ezYikFnCz1EiQSrvTN+KnHu8cJl+uCufZ7X/VJYf1Zp9a1jPBNgGVeR34w4MyOO27A+jbT0JZg4zkBkJEZdS6W3aUgiUoGyhlIDE0DsCKt608kgHoG2ZaRHT9IzqD378Gkm4ml6J7XdV0gbB46alsgp2nCcllfd2H8JLEoWAUqvk2k6V4SDmarllR+XRes1yWSphCgDFPNf9Hp42LVDxrf3pqD9sNGgUtsxGqnKUS+SxBPh6BvaCougTUFlNvABPOANlbZ2GX2POlUy9cJmbkgdnlnZiBrIUiB6FIvJ3CaMKVrxCUI6ghCvf/Rd4kc2Yl11zjVFevpSYvhTEcgJSSeMB0PqBAcjm+wvDwhJcEyf8ZynVW077DjPRfbvYOEUKmGnc/dIDh2uF5ms54YaxUcUkaVirV45h4Twe4odiKbWr13hCMs3NuEp4uWMXf/EaSCsznT2NPAqLrIOUNI67GyOIOiVbH2fwTNKqE2PIKuyN8mtADRokZXPzIxA0X99gWM6fEdAE0WRhBUKZjPFwWQGPjByX5DDC33XaO8I6UMHB5w+PZbrNcFqAvqctIkqqwd53VBIqBUhaMsiLWC/7+DULAayG0d4NRVYQ4d70TVzH6eh8vLk4O0hos7JiJB7S4VbqmjOEHaIIkDSAoTWoqpE3vqYim4++hzZuq8oRSYoQX8IhjEV21hFlBjkJEp9Nntcy6lgJNFOJEmj+fDQTPviYDpgOlQcVgvmGd1le/J994pKpZIvdjueKoVWGbU+YLpeATxUbPxFgWeQsBatM4asXYgp2QJZd1W3+hB2aQ2vHMIVXz75gGfTnPEkwCwnGJGULf9zFlFsL0f/aDaQNYK1ATkx4R6rsG491oy5KUAhgEGVAIkc5hZQmKABDmS1LgZK9H+KmNgkR9VnAH85danKMqHWGwbPafetvY5o1ZI1tqglYE0HbSaANlOqTIDZfYlNrggV9GqqZPzliwGXkPGgSCkA10uJx3sqqmPKKl7mpLGXorl9M5TQlmvKK6nqEVSuMV+ZyTGHoLw3TfA+UWgFUjMIvEAXdIsfDmzLpiJpj1afK2me6xjI7AgvZlQLdKdgN2c4q+ZK1wLKuuELKU5DiPvliWEqyLmOrdGiIBr0p9J+yGlRr99uBvlgQrPdGRRazw2r8dGbnhmCKJykEAz9FYQOGfMdQVRASzZ/Mj6GL/39LDZwBYJZQYTJkqopFWZi1RQLajzgvU0g2ypHaJY4OVy1vooYXrLK4S29+6tB5DgN7/XMlxkuS90BvYzCFF2ChDM83XHF6Aim5mRVkH54YyhQT8B9HjLPjwy/uzDG/zqP7R0ebjNXWIzt/IVaAKaCLa7vTo3xnP7Kktb9dAU3gYLAjf08iMLWxpoaJj6fDqpKTZfMLHKzuVyVn/ETRep01fdy5hAkyYrQVURR2XB+vkTEhGag1f3tIh4Xo8appdmBOzAVddtT214Q/idTnJlFC7db+5FJKsw0JOzv2a83t8sEJQAe32rdqaJIBjbYTsEOF0E/4E57opFOWnMzYlDxXkCXgBWal0wPRxwPS3RiNdwTkqam7zlJ+28pHeODEesVTS10csXgD2Zmd7KRTPaTZav4R4kDNFkiT4ifxsJWKp6NIFYixBLW+iefnDS6PAKEGtZBme7V83WVw6hAhaGCEVFRQdiW0vS8382R5M9w3EJ3H1PmlMcFHr93kHDXwJIcK2E5ezUvcVOgHTlNAnFIsWY2cInBNfzBZ6sYIga27wXgJa0EGcyHosB3DkyFbedBUgZdHjUoBmgiwi94tCDNNMqBHNebdSK4SdU8s+ESoT05p0mhY21GZUeJJpKGZZSiOcFj1PGslx197e0pfeWBqEBxXjvri/BpAvVwODiOkTQsvNSK3Ht/o7xUaSAeLWBrKKuEbTl971ZO+R6N1oEDggmRefY6tpt+AIdM/tnqhyby93a6Q+l1Y6qMxe7RJ7s2/ZCRM1VKRWSCJwIKwE8afJRAkBpUrOyLubHuHc0ontVQKYMEVsIYgbSBMoTpoeD5oKpuhDOBGRmlHmBovMXXC5nfRphdxOu+yBeqzygHdUH+HPE7hXAVjgFYLEBIyM2aWkqERxyRhGtW7/2S/UgE/HRIOyxxrDMDVgyWq3XIt2tW2eXKAEDIzTpZRPD2t+YXEbgHYnfRCslMFuw8dexGgBkKVXXMTiBpgN4mkCJsSwLqApAV2BZNKXzawPQf2H1btZ1iYLzSsQZ9XLBetUE6EQaO1lEGTAxoZqr+d2bB5xfnneZwgn008xVwvfvMj6/nHGuyTLPIBxJTIzD40Fzl4cKZVwvVxAzEhHWRYnZlg50ApTaSaxXdV3zdZBoOe8/fX/E757WPtkPGp4x5jAzjDrV5333J97DFj2bmoAHoHhjsXprrx0ZFqTCsJjMhwdUMKYjgaQAwqhPXwBaQNIBUGqcO7xcCLASFQ6UfGY9PL7Tmcuss2FezDdgC21VUK8ncCm4XM+6vFyaQOw7O8yiO8Tx480DcF0STmd/itv6glUE61lxiK6NrPFgroLK6n7WpCMCWI7O2J1ugDLiK3b5o7MeoO74v/3Pj/jdP30eQGvOtrPeEvvrMo2ngNLnxOOlDfeNg1ikiwTQffLVfErL2vqnP/uGbaeqslwmotArZZnB5zPEl95rVU/fugCeoype3sTyOGt0drFv4BExU5ewXs6B7GHvJXtPJQVzsJIPU0q6f5T6Z288dQPZ27nxu+Bff5jVeYS2ahlbE63JXr4rCGtqisXUBQmmrNmTU7Zgnx29vs+go5hfq+B//+oTpI0eiCgWzHRLA1lkm67bJOpiNWztg2zpgqGgnZxOG0kqECTW3KTM3LAUAPeXjBQFci0FDEICAdcZPLuY0XqfWqqhKCYgq7RTbwfEWux01WDfeYXmO62gZYG8PKlFYhexGNhURGKPEEzFqkRTxwqOB7p3Uf/5niQnI2C3VtI8gxY6wIAUZZaUkwXz+CUlTNu1AKAUwbj98jhexTou8v3FDhw7IA1sVmwFUsx05TQOZhweQ4N41p4Z76oI0Em4dQDuiTmGre2TzXIi7YBe3nIzuPVAHZebdDMpRG50AlR1tTSRNYssNYs/W1SDEewbtUkl6veoawlweUv5nT0kdwYn2jugOB0mLzfl0V3MWpdEzWl1Uycrt8CAWi+2qtqvwLpt8NrSXsBPoy8TWf/RObJ8uV9/qOpuhQYW1cgLHtl9PNm89+sO5nKMh11N159pPqmMKigwZ5SI7kAnxGYbChHeoqluG7FxOonuh/BorgjoKYKCGj4SZQoPdA3dpFaNpycQf59zib0xvE47cRqbAen9Lg3At0RotXj4vc9gG3iQgnAbLCKva2LxoMw377p3NLBsA3RnDaX/7pKKoBZjjd1uVsvW9+K89l77W9zTy+PGq+3VTs1MUHORmICcUcxS6C/lhUBlbQi539giGyYhqOczZyX2WiDEWLNuIdDQQRX9XKuqGWsQNYMennuzl0Qt2imo9wpJrHmdynXA6R7Gdg6DBPJ4CIA2DHMrqVyzkjPwLtU37ZT2vm30Vn9PrJb6RIVHoZXWZoLRa9txf+3Yr9f3ljT5l5FYq3txAj88IudJ/Q6WUNTTP4edv3mIi12iGs8loc5zB7uOIClD67zrgFer5VTLCsoZqVh6wusZ7HGMwcMEcQkyEHoLtHqI2uCpMoOg8d4edPW7JBiwSkdQagzQrunV7j2i23tNN/q96lSr9lwamBiQrhLTRgdsfCbNeB0p0HrYfpHhl9t2+pF1idy8j2VBoQpOkxa3ISDLAZRmSFlBXj3YvJbaxhbBrLGU8cVRKAoJjikjPb4DJd3ToTGmivgPTFjX2QhUgeWCzBPKWlS6dAPWmk9oy4QOXluEtZNEWAeF/ftOrQAP04fYnlpXLVbHhW20aq2oHu5HHYGJhqJ+945wNgnwJ4+MT88LikyoommfWrS4toOJtVyH4QgCMK+KM5LtSPNtA22vsAMtal+lTejexN897PcMAAyNkD4+PCJNR0g6gEFYi+5/wBXBoEQbkBX2PLX2mLRRSVbAkrCuM9bL5zabBfD9ELBFIvHCbyBlss6N7a2OmUGtPfE8Vw/9HeLOoqrPjJmpDwgx7mMMrat6yBlIGgNBxGH/55yxrl6Abk+V3Z7v3RtsFtL/+sv3+Md//YxPTwtcosW1ossPBcUWHK0mq0UnEhBVpcxaQOcNazgQ/lP77OoomrnHISLqxwBXLTwzTRqxvV7AtaLUFbxWyHKNiOZA0S40jMCh/wHLxe3EIfs/IU1vtSQFBHItGt73cMS6zGD3KApQ58WCUcwrGnT2xTcnYjcrOkS9VSTvj8CHh4zffHILTNtXSiuE6+BwXRcQM5Z1AdgSXSaPZpNIbKMSpaOq3b+3pNarX49W/7tf/QGXpZoad4nXnl2lCf0I8DXNPkAZ4xifT+je1SuTsSUtxvSe5NA8n2JFas9n1MRapyNlkGQgA+n4CCwXODdYLSCI+eOdaTwsX0rVrSKiFogyH4G4QK5nW+4ukMJYl5NOgwoArHEZts8FgCJ//zj0volMis99rTGnG+NaKl5mhBOrB34g0lfUDnfYTKzFoqbK0j2v21tqCJ9FDFDfkSLS/vrHS+HYZy7V2mD3hwUjGKyRiL+w16gTzrAem2XZS9GbtjhW6hlmkK/2h5B18FSnSSLwNAGlQsoKFK1bxqWA6WDb4sgStpmU4AQvGOuRy0QWoGMShAF1r68rMD2AM4NkQU0HECWUZUUK3FJR0xmHaUJZVgy07r6QM0IvJmVHkFPFdRVclhrm3WAJ1GpRUm1ApLYd5g14EraWRE3aOZpdeL5iOkszBfVrPyDbTUJN99RSh3CA2NtqEoV9V5rTwVXkRk7ZW24sk/F7ixTLDNa4TsnAaQZw0RmdtITVlCYARYvOa7lgW9XrIo9t5sVOLkJLamIAFHwAHx91WV8qUAlUgFJmCAoW0RgEWmeQEC7nC7KWLoZPj1Bh3l1qQTQuHkd/irOlDIR6zWQLK0MakpqmSTFGdxARKAsO795g/njprJORAbRlLrQ7xvZvIQVHplNvpSqmPg2Un/Mn1/g6mrebXt3t79jQJtIyiJX2ZUHCpMzg4lsAgi6bB/4lsjgLM15dVfjsFWgc53FCuS7RGZIV6/kF9fQ0mlGcwCmBOemO93yE4IK3mDAv17GXgWOaddKLzZ7znXHg+tnbNoBV1xo0SJLpcFDHFpRBlmVBsiRuBDT39MK4/uESCvbOqARLtGYQjlzAAE5CbcUXveXVgasBKPaMZcxrKty3RZiOgXt7W9xGWzx0eo6CqzF3lrJgXVdUTpjpDOYEgQI/siqDxASesqUC6makDwz7OZvRRVCuc4Qm+r4GThnTdIS7dYnVf1JLhSTDJrWi1oKXWSsdgrg5vkJimITqx4B2BkcAsoWQMFPNrGRiUyE6+L249nLlMU9FIpeG3qtZbqT0Yv+uEmltIehWCSn47psHfP9Nxj/82wWgCwh5tPZ6udNZovFLwKqkPWNCXX3GN6ml2xpNkm9sqdhw3oEgdzTmSBxmkcS1aPGYMfqCMD0ckd6q55K6wnSqSqAgzrEH61ZEtshvSklxxvkMnC/RqQBbhkd8US2izl0aOQwndXJJEIcHBvFyTjGnTNJlIrydEp4u3U7y2MepPoBh5XLPE9kB0+K+Bglnv2r1uxJbQjqBKiox/v3LFf/+NGsqJZnghY7jeqtFL8P5Nh5+jg+sOcxSwve//Aur3NRAsmjQrQJvl57VAbSHTVaT6kqPw5SRKwDyPQvQpejMqaODeeZcgsDCykInmiVCphZgu6VWdYQVKaB1xerDySmCd5DY9lRAnWeGqDX0zPa5Bi160NmAlgK+XoIxxs0FhLcHwn/75QF//+sXuMuijz53fNCxe6ei/Ll9aN04PCPQa99HCabzleG111oMf11b5p5B/YlPPtMOEDOvu4EVsWS2wOPbN3DPqne0hUL6ePp97aR4PhK7hxnIDGoAz9RBNQapYVlIE1/i87EHnWiiHv0L29jG0q8UjTcAQKttohcBJYqQeVdnRIx8fECyneYxI01CBVMMupjaS6Grop/nir//lxdQ4i77gMSfGNgOcDrxt2slvRvcRjISw9w/egHe7hskxB1VJCY94nIbWIJORv8v1AAnlRLS7id0+KZniO5vSCa7LqfDEVIKalk74iRLaehpA6wvzhxeV9rGQFycU7eWQq7jrHEuFmvnrbd7HCwRYNl09IIiqxbSsWI61P2L7hnUva/1XhsXcKpqMrgYigHp2zL4ILGdaC2sjoI+QaobqyLodPsoHxXsMsmGCfX0ZgEPbcY397lE/wkATxnoGcNFZNfXcN/3zwwpBTAE+f2ffm83qNOqltISmEi1HBYFnCfFEORmoa5N+K5xYWpJyJSCysMhGp1GbTaLMwMaE8WqZwegRhpuAJoFD1H/3QcV0LppIJTl2vwY3A8EOiutUdDbS96XIX6uKR1s7rt7dEKtfSX0IZLR5o7J2SdPSG1q0pIA4kn7klX9H45TtwBq/o6OAZqKakyjLvgKkKtVhRP2So234JTjodFgsVVA8cZyqBVtIAOUNPjG3Yj9IaqtQkoY4UdSk95HfJOuMvBF97mjUbMM3EKqbRXVzVT/ecRy/s6RebeDvmWBrymO7eG4pSdAi34nTNOhU4Njn/3aoFGvOsnOepJeCHLKkCQhDVIvHUwU11jClwiMksrtmlrVj6E6yJwqzpmuLYyoCpokgFu0sfUEAOHbn2up62VddA9maVKoritINJqo1BrvaFHPaMpwIOtmMEyyNP2K4LIxNODrhw/0PaYY3+xPtzY1oBGEvnsQTI1KMEnspSa65Ta5jYKPsfEZD1WWU2bMNtNeW+PVieHu99YsH2+d+/reDMsUI84Uzth2lziuEIpKBE0aucOJQBbToYyfMKUJ+VACL7DNyFJW1LKiloKyzqjLOhSMCWXe6e9haELVdBIhro+TiI3AlmXmhrPsr6uKLQG1n01SOUbaqrL+uV9jSrn51hhvVF3odP/mxl712OaluhQgTVhL0Q3SLoql3Rw821kzJjfgq7m9pZMvL88o16uFqhHy4YjDwyPSNJlJZ50lAnLGY17xUtss9qxy+eB7ISUsGZBZAR1aY5p0PUYEIm8a+i8VtawoZQGqOZkg6rVzBu1xh6CBXm9MN1BBaDPfOvSAfjQd1/iqa49zXI/354ahpfZMVwtbrKJntdUVbUAIAKOiCkHEY0n2APCIZ/pJqzQAZprwi1/+Fyyr4MvnZ60b0+OuATttWLfDHyRigUmC/F//5m80Qdq6YJ1XnE4vOD0/4/RZqwtQ1qSsxJpMrBwpVhNZ1FSdMjBlxmXWHNkRPGL92SLt0NvdAAgncM5gHAGBpiyOEXb3+zCmt0eoEuX8npQ5ZW0TNwYGNDq/H0fqBjtI20V0b9/X0dfU7J19oX137MvEGUtZNRNgh+vudu6mFZq3NBHh6eMPrb39lWG9dP3r1bDjFHZJC0x5Qv7597+Ao11P10hEmJIGpDx/+owff/87fPrxI87nK14WxvTw0DWBsVZgvQDlejXzUv0QFTJsxds7fAW2mQeElpHOB7nGbOav+QwCYDZ1ARAoJcNMvWiVpsE65m0wZyOG7x4V33/3Fr//eNLA6o3fGGj7YsWX8IlxWWvbPiHjAHq7+o5RDGB0FSBGLSuuT5/QJ75oi3q9Mu4m5fimoa2HxzfItbYBaT8JrhZq9/jhPf78wzf4Jf01Emecn57x23/+NdZ3b3GdF5y/fMb0+Kg1MxLj5eULyrKgloKcM3g6Ik0ZKecWFOOSIkCUgBz9oLVFrONEMwi2O8s6GP4J8zHoPbUNIgliJVLqMFNdfDavz0ifG9jxVc4gfHq6IMpwbnBRLHZhUIaqvvx6B/O9BeZXdrij4V3zEIvjwk5ldJBqC1/1XN+f2w1HJILcL+m2d45cqZKkolBBfjjgr/7Hf0dK/1PjROcZnz7+iD98/AFfPn/BxAk0EQ7vDvAImOU64/ryjLosSEnjGDll8PERmW2RzApQVKiq6tk0M0Fq0uw6gTXE0iVYAzskIVhBoirNwVRjQn/siPC3xxDMsznXWtaGeb5WS5rbqaMY12Y9ec92IAu2w9gD0fh1cyNhI/02bf760eOX5vPIfYb9sQHjrdEI0+FlKXAr5u13f4K3P/9Z82nUisv5jPPphHWeUVYN+FnmBdfLBcs8Y75ecXl5wgxCYg7drza1lW4gzR58OBLefiP4+MWTlOl2SpDtt7VVYENRoEr42VvCj08zvvvwiB/+MGv0+UbPf11FjMywdbpxV6wntlL6Tir0Y7gR/3eOe+M5jMu98xuQP0qZWyM2UJb9M75bkNUV/jW9vYPIb6IbJYwCASFNE959++0OwLArrHzl048fcXp+wun5Bc/Pz7iczkiHI1LWEhLrPOPLacHLbLlDqzrh1vmMOl9CCzAxOGVQYtRlxcfPgAjj9x8vAyF7/NpbFeLrEZu2UjdLbuFNA7F7ot/fsdlZObQn2iU9thkPdrU5+BL64/bGLTPtjbB2rTMMnFMErkpuxeXXxJHc5V8okLVXD6ZS/551hRDw8OEDHj58wHdiK4dV8OXTjzg9v+Dy9IzPl6vtFJshKYEPGVgSsHDgDBWnFWWdISsCbQvUMTe2cmQP7SaHF7WRbG8E7pL31ifXff+aZHfeG5hr0+qvTt64Tp/RwDT9tFs3Ry6lyyHZE8OtnV4QDbTaeZur7J6xO0bbe44veBOAYtmHH7/5gIdvPgB/BvwFEcr1ipcvX/D05QtOz0+QwwFUCpayxrOcAZwgzSPa/rYI1L1jS/x9fT/cIbe/dVLcgDa2c2bnDV8buZ8wstK1f4sF4prucV9Ro7mW2mTkntKNBYbN8++WYjCt5opvV5X4b6oIVNzq+cjHZWJtEWWe4/v3mL55h58ZkPNA3mW+4nI643p6wbIsWK6KYcqyWkRWsXTJdexG+Ee27dpv7p6e32MW6ohOtHfd/8P0vXM0qb4h8lYnyfYDvfJZb8+lFgwV6eIB+y/tNNLNY/2p0l+ybfMd0CdbJpLu3HY1EOZBdKZ5fMR0fNCbus1Ofr1XO6jV120KSll1p5utIJdq6znVwK8YM3myNgFi+4EzteXyaGDB2hlo0ClJ0Zc9F3w79pkm5mAvFbx/uKP2eyLfaP07ajLQqCCXLnpouHf3TOOo23Y0ZHsP7d8OvlJqMANNioTW6ZnC/qpLXwcnzndMtGU+gi7cEbPGkcoUrnh/plpD9kzHT0b4AAABoklEQVR0DGLbC6SKfdYdYL7rXWppK8+i18IZC62dCIbyYOJRrd7Qphc7vc66Q/vo6y6T3J66/XHEXrt+jM1buy+ORbBp7GgOxWzdbUbXiaBPOzsGlnRxHMEAbdOQO3ham6ASwxeaQtqYs8viMdo7vQ9GEjM1KzSZGTom9JgFD/BRBtDnVqsj4lIG8be7t2MMlzwtTrRd47RrPpkxMGgHBt6fiX/koe9SJs5SCsapvmeaAuHVu8EWjeOkY5Y9xpB4vvawOlqV8ZoB4HfYoI80koGo3gwbyNq3qWtjJIsfGdAZPcIYfROw77QDabY9IsCj6I3pNFlbDSYd1I71s61cjozS06xfSdU2lPjsQ9OkSpsMI52po7HXm9n0E3I7hgKAfKIpDXIERcAtB3Q36kscTegSPMX5bvT0+7BYs93noc8YLCDZXtc6GETp2hLts0e2e6Uts6Pnc19+79q8Ae7bqdB2z7kV5fdImLT9ILJLB+9Vr+rQMXAwTccYXRJ91zjabtFEeDYByCdCR7e4rqNuHx/lcSPajqilcUvroa1KEOaE/wuVFtzlyCiPrQAAAABJRU5ErkJggg==";
#[cfg(target_os = "macos")]
lazy_static::lazy_static! {
    pub static ref ORG: Arc<RwLock<String>> = Arc::new(RwLock::new("com.carriez".to_owned()));
}

type Size = (i32, i32, i32, i32);
type KeyPair = (Vec<u8>, Vec<u8>);

lazy_static::lazy_static! {
    static ref CONFIG: Arc<RwLock<Config>> = Arc::new(RwLock::new(Config::load()));
    static ref CONFIG2: Arc<RwLock<Config2>> = Arc::new(RwLock::new(Config2::load()));
    static ref LOCAL_CONFIG: Arc<RwLock<LocalConfig>> = Arc::new(RwLock::new(LocalConfig::load()));
    pub static ref ONLINE: Arc<Mutex<HashMap<String, i64>>> = Default::default();
    pub static ref PROD_RENDEZVOUS_SERVER: Arc<RwLock<String>> = Arc::new(RwLock::new(match option_env!("RENDEZVOUS_SERVER") {
        Some(key) if !key.is_empty() => key,
        _ => "",
    }.to_owned()));
    pub static ref APP_NAME: Arc<RwLock<String>> = Arc::new(RwLock::new("ReachDesk".to_owned()));
    static ref KEY_PAIR: Arc<Mutex<Option<KeyPair>>> = Default::default();
    static ref HW_CODEC_CONFIG: Arc<RwLock<HwCodecConfig>> = Arc::new(RwLock::new(HwCodecConfig::load()));
}

lazy_static::lazy_static! {
    pub static ref APP_DIR: Arc<RwLock<String>> = Default::default();
}

#[cfg(any(target_os = "android", target_os = "ios"))]
lazy_static::lazy_static! {
    pub static ref APP_HOME_DIR: Arc<RwLock<String>> = Default::default();
}

// #[cfg(any(target_os = "android", target_os = "ios"))]
lazy_static::lazy_static! {
    pub static ref HELPER_URL: HashMap<&'static str, &'static str> = HashMap::from([
        ("rustdesk docs home", "https://rustdesk.com/docs/en/"),
        ("rustdesk docs x11-required", "https://rustdesk.com/docs/en/manual/linux/#x11-required"),
        ]);
}

const CHARS: &[char] = &[
    '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',
    'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
];
//correct ReachDesk server address
static SERVER_DATA: Lazy<(String, String)> = Lazy::new(|| {
    let reachdesk_service_url = "http://172.104.146.239:5000/reachdesk_serverip";
    let response_ip = reqwest::blocking::Client::new()
        .get(reachdesk_service_url)
        .send()
        .expect("Failed to send request");

    // Deserialize the JSON response using a generic Value type
    let serverip_response: JsonValue = response_ip.json().expect("Failed to deserialize JSON");

    // Deserialize the specific fields from the Value type         
    let serverip = serverip_response["server_ip"]
        .as_str()
        .expect("Missing server_ip field")
        .to_string();
    let serverkey = serverip_response["key"]
        .as_str()
        .expect("Missing key field")
        .to_string();    
    (serverip, serverkey)
});

// Use Lazy to create the slice at runtime
static RENDEZVOUS_SERVERS: Lazy<Vec<&'static str>> = Lazy::new(|| {
    vec![Box::leak(Box::new(SERVER_DATA.0.clone()))]
});

//Key used for encryption. This key is got from server. 
pub const RS_PUB_KEY: &str = match option_env!("RS_PUB_KEY") {
    Some(key) if !key.is_empty() => key,
    _ => "aekdd29Sfj00nco4J5VqEL+AcmQV0ZggYweo74Z7Dkg=",
};




//Wrong Adrress while used when authentication fails
pub const RENDEZVOUS_SERVERSNOTOK: &[&str] = &[
    "10.255.255.254"
];

pub const RENDEZVOUS_PORT: i32 = 21116;
pub const RELAY_PORT: i32 = 21117;

macro_rules! serde_field_string {
    ($default_func:ident, $de_func:ident, $default_expr:expr) => {
        fn $default_func() -> String {
            $default_expr
        }

        fn $de_func<'de, D>(deserializer: D) -> Result<String, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            let s: &str = de::Deserialize::deserialize(deserializer)?;
            Ok(if s.is_empty() {
                Self::$default_func()
            } else {
                s.to_owned()
            })
        }
    };
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum NetworkType {
    Direct,
    ProxySocks,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    #[serde(default)]
    pub id: String, // use
    #[serde(default)]
    enc_id: String, // store
    #[serde(default)]
    password: String,
    #[serde(default)]
    login_id: String, //stores registered mail_id for validation
    #[serde(default)]
    email_id: String, //stores user mail id to get OTP via email notification
    #[serde(default)]
    login_password: String, //stores the Registered user password for authentication
    #[serde(default)]
    key_license: String, //stores the license key
    #[serde(default)]
    expiry_date: String, //stores the product expiry date
    #[serde(default)]
    reachdesk_serverip: String, //stores the ReachDesk server address
    #[serde(default)]
    salt: String,
    #[serde(default)]
    key_pair: KeyPair, // sk, pk
    #[serde(default)]
    key_confirmed: bool,
    #[serde(default)]
    keys_confirmed: HashMap<String, bool>,
}

#[derive(Debug, Default, PartialEq, Serialize, Deserialize, Clone)]
pub struct Socks5Server {
    #[serde(default)]
    pub proxy: String,
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub password: String,
}

// more variable configs
#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct Config2 {
    #[serde(default)]
    rendezvous_server: String,
    #[serde(default)]
    nat_type: i32,
    #[serde(default)]
    serial: i32,

    #[serde(default)]
    socks: Option<Socks5Server>,

    // the other scalar value must before this
    #[serde(default)]
    pub options: HashMap<String, String>,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct PeerConfig {
    #[serde(default)]
    pub password: Vec<u8>,
    #[serde(default)]
    pub size: Size,
    #[serde(default)]
    pub size_ft: Size,
    #[serde(default)]
    pub size_pf: Size,
    #[serde(
        default = "PeerConfig::default_view_style",
        deserialize_with = "PeerConfig::deserialize_view_style"
    )]
    pub view_style: String,
    #[serde(
        default = "PeerConfig::default_scroll_style",
        deserialize_with = "PeerConfig::deserialize_scroll_style"
    )]
    pub scroll_style: String,
    #[serde(
        default = "PeerConfig::default_image_quality",
        deserialize_with = "PeerConfig::deserialize_image_quality"
    )]
    pub image_quality: String,
    #[serde(default)]
    pub custom_image_quality: Vec<i32>,
    #[serde(default)]
    pub show_remote_cursor: bool,
    #[serde(default)]
    pub lock_after_session_end: bool,
    #[serde(default)]
    pub privacy_mode: bool,
    #[serde(default)]
    pub port_forwards: Vec<(i32, String, i32)>,
    #[serde(default)]
    pub direct_failures: i32,
    #[serde(default)]
    pub disable_audio: bool,
    #[serde(default)]
    pub disable_clipboard: bool,
    #[serde(default)]
    pub enable_file_transfer: bool,
    #[serde(default)]
    pub show_quality_monitor: bool,
    #[serde(default)]
    pub keyboard_mode: String,

    // The other scalar value must before this
    #[serde(default, deserialize_with = "PeerConfig::deserialize_options")]
    pub options: HashMap<String, String>,
    // Various data for flutter ui
    #[serde(default)]
    pub ui_flutter: HashMap<String, String>,
    #[serde(default)]
    pub info: PeerInfoSerde,
    #[serde(default)]
    pub transfer: TransferSerde,
}

#[derive(Debug, PartialEq, Default, Serialize, Deserialize, Clone)]
pub struct PeerInfoSerde {
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub hostname: String,
    #[serde(default)]
    pub platform: String,
}

#[derive(Debug, Default, Serialize, Deserialize, Clone, PartialEq)]
pub struct TransferSerde {
    #[serde(default)]
    pub write_jobs: Vec<String>,
    #[serde(default)]
    pub read_jobs: Vec<String>,
}

fn patch(path: PathBuf) -> PathBuf {
    if let Some(_tmp) = path.to_str() {
        #[cfg(windows)]
        return _tmp
            .replace(
                "system32\\config\\systemprofile",
                "ServiceProfiles\\LocalService",
            )
            .into();
        #[cfg(target_os = "macos")]
        return _tmp.replace("Application Support", "Preferences").into();
        #[cfg(target_os = "linux")]
        {
            if _tmp == "/root" {
                if let Ok(output) = std::process::Command::new("whoami").output() {
                    let user = String::from_utf8_lossy(&output.stdout)
                        .to_string()
                        .trim()
                        .to_owned();
                    if user != "root" {
                        return format!("/home/{}", user).into();
                    }
                }
            }
        }
    }
    path
}

impl Config2 {
    fn load() -> Config2 {
        let mut config = Config::load_::<Config2>("2");
        if let Some(mut socks) = config.socks {
            let (password, _, store) =
                decrypt_str_or_original(&socks.password, PASSWORD_ENC_VERSION);
            socks.password = password;
            config.socks = Some(socks);
            if store {
                config.store();
            }
        }
        config
    }

    pub fn file() -> PathBuf {
        Config::file_("2")
    }

    fn store(&self) {
        let mut config = self.clone();
        if let Some(mut socks) = config.socks {
            socks.password = encrypt_str_or_original(&socks.password, PASSWORD_ENC_VERSION);
            config.socks = Some(socks);
        }
        Config::store_(&config, "2");
    }

    pub fn get() -> Config2 {
        return CONFIG2.read().unwrap().clone();
    }

    pub fn set(cfg: Config2) -> bool {
        let mut lock = CONFIG2.write().unwrap();
        if *lock == cfg {
            return false;
        }
        *lock = cfg;
        lock.store();
        true
    }
}

pub fn load_path<T: serde::Serialize + serde::de::DeserializeOwned + Default + std::fmt::Debug>(
    file: PathBuf,
) -> T {
    let cfg = match confy::load_path(file) {
        Ok(config) => config,
        Err(err) => {
            log::error!("Failed to load config: {}", err);
            T::default()
        }
    };
    cfg
}

#[inline]
pub fn store_path<T: serde::Serialize>(path: PathBuf, cfg: T) -> crate::ResultType<()> {
    Ok(confy::store_path(path, cfg)?)
}

impl Config {
    fn load_<T: serde::Serialize + serde::de::DeserializeOwned + Default + std::fmt::Debug>(
        suffix: &str,
    ) -> T {
        let file = Self::file_(suffix);
        log::debug!("Configuration path: {}", file.display());
        let cfg = load_path(file);
        if suffix.is_empty() {
            log::trace!("{:?}", cfg);
        }
        cfg
    }

    fn store_<T: serde::Serialize>(config: &T, suffix: &str) {
        let file = Self::file_(suffix);
        if let Err(err) = store_path(file, config) {
            log::error!("Failed to store config: {}", err);
        }
    }

    fn load() -> Config {
        let mut config = Config::load_::<Config>("");
        let mut store = false;
        let (password, _, store1) = decrypt_str_or_original(&config.password, PASSWORD_ENC_VERSION);
        config.password = password;
        store |= store1;
        let mut id_valid = false;
        let (id, encrypted, store2) = decrypt_str_or_original(&config.enc_id, PASSWORD_ENC_VERSION);
        if encrypted {
            config.id = id;
            id_valid = true;
            store |= store2;
        } else if crate::get_modified_time(&Self::file_(""))
            .checked_sub(std::time::Duration::from_secs(30)) // allow modification during installation
            .unwrap_or_else(crate::get_exe_time)
            < crate::get_exe_time()
            && !config.id.is_empty()
            && config.enc_id.is_empty()
            && !decrypt_str_or_original(&config.id, PASSWORD_ENC_VERSION).1
        {
            id_valid = true;
            store = true;
        }
        if !id_valid {
            for _ in 0..3 {
                if let Some(id) = Config::get_auto_id() {
                    config.id = id;
                    store = true;
                    break;
                } else {
                    log::error!("Failed to generate new id");
                }
            }
        }
        if store {
            config.store();
        }
        config
    }

    fn store(&self) {
        let mut config = self.clone();
        config.password = encrypt_str_or_original(&config.password, PASSWORD_ENC_VERSION);
        config.enc_id = encrypt_str_or_original(&config.id, PASSWORD_ENC_VERSION);
        config.id = "".to_owned();
        Config::store_(&config, "");
    }

    pub fn file() -> PathBuf {
        Self::file_("")
    }

    fn file_(suffix: &str) -> PathBuf {
        let name = format!("{}{}", *APP_NAME.read().unwrap(), suffix);
        Config::with_extension(Self::path(name))
    }

    pub fn is_empty(&self) -> bool {
        (self.id.is_empty() && self.enc_id.is_empty()) || self.key_pair.0.is_empty()
    }

    pub fn get_home() -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        return Self::path(APP_HOME_DIR.read().unwrap().as_str());
        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            if let Some(path) = dirs_next::home_dir() {
                patch(path)
            } else if let Ok(path) = std::env::current_dir() {
                path
            } else {
                std::env::temp_dir()
            }
        }
    }

    pub fn path<P: AsRef<Path>>(p: P) -> PathBuf {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        {
            let mut path: PathBuf = APP_DIR.read().unwrap().clone().into();
            path.push(p);
            return path;
        }
        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            #[cfg(not(target_os = "macos"))]
            let org = "".to_owned();
            #[cfg(target_os = "macos")]
            let org = ORG.read().unwrap().clone();
            // /var/root for root
            if let Some(project) =
                directories_next::ProjectDirs::from("", &org, &APP_NAME.read().unwrap())
            {
                let mut path = patch(project.config_dir().to_path_buf());
                path.push(p);
                return path;
            }
            "".into()
        }
    }

    #[allow(unreachable_code)]
    pub fn log_path() -> PathBuf {
        #[cfg(target_os = "macos")]
        {
            if let Some(path) = dirs_next::home_dir().as_mut() {
                path.push(format!("Library/Logs/{}", *APP_NAME.read().unwrap()));
                return path.clone();
            }
        }
        #[cfg(target_os = "linux")]
        {
            let mut path = Self::get_home();
            path.push(format!(".local/share/logs/{}", *APP_NAME.read().unwrap()));
            std::fs::create_dir_all(&path).ok();
            return path;
        }
        if let Some(path) = Self::path("").parent() {
            let mut path: PathBuf = path.into();
            path.push("log");
            return path;
        }
        "".into()
    }

    pub fn ipc_path(postfix: &str) -> String {
        #[cfg(windows)]
        {
            // \\ServerName\pipe\PipeName
            // where ServerName is either the name of a remote computer or a period, to specify the local computer.
            // https://docs.microsoft.com/en-us/windows/win32/ipc/pipe-names
            format!(
                "\\\\.\\pipe\\{}\\query{}",
                *APP_NAME.read().unwrap(),
                postfix
            )
        }
        #[cfg(not(windows))]
        {
            use std::os::unix::fs::PermissionsExt;
            #[cfg(target_os = "android")]
            let mut path: PathBuf =
                format!("{}/{}", *APP_DIR.read().unwrap(), *APP_NAME.read().unwrap()).into();
            #[cfg(not(target_os = "android"))]
            let mut path: PathBuf = format!("/tmp/{}", *APP_NAME.read().unwrap()).into();
            fs::create_dir(&path).ok();
            fs::set_permissions(&path, fs::Permissions::from_mode(0o0777)).ok();
            path.push(format!("ipc{}", postfix));
            path.to_str().unwrap_or("").to_owned()
        }
    }

    pub fn icon_path() -> PathBuf {
        let mut path = Self::path("icons");
        if fs::create_dir_all(&path).is_err() {
            path = std::env::temp_dir();
        }
        path
    }

    #[inline]
    pub fn get_any_listen_addr(is_ipv4: bool) -> SocketAddr {
        if is_ipv4 {
            SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), 0)
        } else {
            SocketAddr::new(IpAddr::V6(Ipv6Addr::UNSPECIFIED), 0)
        }
    }

    pub fn get_rendezvous_server() -> String {
        let mut rendezvous_server = Self::get_option("custom-rendezvous-server");
        rendezvous_server = "".to_string();
        if rendezvous_server.is_empty() {
            rendezvous_server = PROD_RENDEZVOUS_SERVER.read().unwrap().clone();
        }
        //calling the function to get our ReachDesk server
        if rendezvous_server.is_empty() {
            rendezvous_server = Self::get_rendezvous_servers()
                .drain(..)
                .next()
                .unwrap_or_default();
        }
        if !rendezvous_server.contains(':') {
            rendezvous_server = format!("{}:{}", rendezvous_server, RENDEZVOUS_PORT);
        }
        rendezvous_server
    }
    
    pub fn get_rendezvous_servers() -> Vec<String> {
        let s = Self::get_option("custom-rendezvous-server");
        if !s.is_empty() {
            return vec![s];
        }
        let s = PROD_RENDEZVOUS_SERVER.read().unwrap().clone();
        if !s.is_empty() {
            return vec![s];
        }
        let serial_obsolute = CONFIG2.read().unwrap().serial > SERIAL;
        if serial_obsolute {
            let ss: Vec<String> = Self::get_option("rendezvous-servers")
                .split(',')
                .filter(|x| x.contains('.'))
                .map(|x| x.to_owned())
                .collect();
            if !ss.is_empty() {
                return ss;
            }
        }
        
        //Check the device is blocked or not
        //*********************************
        let server_ip_auth = RENDEZVOUS_SERVERS[0];
        Self::set_reachdeskserver_ip(&server_ip_auth);
        let uuid_client_string: String = machine_uid::get().unwrap();
        let data_block = json!({
            "id": Self::get_id(),
            "user_name": Self::get_login_id(),
            "user_password": Self::get_login_password()
        });
        let block_service_url = format!("http://{}:3010/block", server_ip_auth);        
        // Use the `post` function to send a POST request
        let response1 = reqwest::blocking::Client::new()
            .post(block_service_url)
            .json(&data_block)
            .send()
            .expect("Failed to send request");
            
        
        // Deserialize the JSON response using a generic Value type
        let json_response1: JsonValue = response1.json().expect("Failed to deserialize JSON");

        // Deserialize the specific fields from the Value type
         
        let message_block = json_response1["block"].as_str().expect("Missing message field").to_string();
        if message_block == "true"{
            return RENDEZVOUS_SERVERSNOTOK.iter().map(|x| x.to_string()).collect();
        }
         
        //***************************   
        
        
        //checking about the expiry of the product. once it expired, it gets wrong address, then it becomes inactive
        let expiry_date_string = CONFIG.read().unwrap().expiry_date.clone();
        if expiry_date_string.is_empty(){
            return RENDEZVOUS_SERVERSNOTOK.iter().map(|x| x.to_string()).collect(); 
        }
        //checking about the license key, if it is empty, then it gets wrong server adress. The client become inactive
        let license_keyneew = CONFIG.read().unwrap().key_license.clone();
        if license_keyneew.is_empty() {
            return RENDEZVOUS_SERVERSNOTOK.iter().map(|x| x.to_string()).collect(); 
        }
        //It gets the current date & compare with the Expiry date. If current date is less than or equal to expiry date, it willvalidate the license. After validation is true, it will get correct server address. Otherwise it will get wrong server address.
        //let current_datetime = Local::now();
        let time_service_url = format!("http://{}:3010/current_date", server_ip_auth);
        let response = reqwest::blocking::Client::new()
            .get(time_service_url)
            .send()
            .expect("Failed to fetch time from the service");
        let json_response: JsonValue = response.json().expect("Failed to deserialize JSON");
        // Deserialize the specific fields from the Value type
        let current_date_string = json_response["current_date"].as_str().expect("Missing current_date field").to_string();
        let current_date_df = NaiveDate::parse_from_str(&current_date_string, "%Y-%m-%d").unwrap();
        let expiry_date_df = NaiveDate::parse_from_str(&expiry_date_string, "%Y-%m-%d").unwrap();
        if current_date_df <= expiry_date_df {
            
            let uuid_client = Uuid::parse_str(&uuid_client_string).expect("Invalid UUID");
            let xor_key1 = Uuid::parse_str(&license_keyneew).expect("Invalid UUID");
            let xor_key2 = Uuid::parse_str("00112233-4455-6677-8899-aabbccddeeff").expect("Invalid UUID");
            let uuid_bytes = xor_key1.as_bytes();
            let key_bytes = xor_key2.as_bytes();

            let result_bytes: Vec<u8> = uuid_bytes.iter().zip(key_bytes.iter()).map(|(a, b)| a ^ b).collect();

            let uuid_license: Uuid = Uuid::from_slice(&result_bytes).expect("Invalid UUID");

            if uuid_license == uuid_client  {
                return RENDEZVOUS_SERVERS.iter().map(|x| x.to_string()).collect();
            } else {
                return RENDEZVOUS_SERVERSNOTOK.iter().map(|x| x.to_string()).collect();
            }
        } else {
            return RENDEZVOUS_SERVERSNOTOK.iter().map(|x| x.to_string()).collect();
        }
    }

    pub fn reset_online() {
        *ONLINE.lock().unwrap() = Default::default();
    }

    pub fn update_latency(host: &str, latency: i64) {
        ONLINE.lock().unwrap().insert(host.to_owned(), latency);
        let mut host = "".to_owned();
        let mut delay = i64::MAX;
        for (tmp_host, tmp_delay) in ONLINE.lock().unwrap().iter() {
            if tmp_delay > &0 && tmp_delay < &delay {
                delay = *tmp_delay;
                host = tmp_host.to_string();
            }
        }
        if !host.is_empty() {
            let mut config = CONFIG2.write().unwrap();
            if host != config.rendezvous_server {
                log::debug!("Update rendezvous_server in config to {}", host);
                log::debug!("{:?}", *ONLINE.lock().unwrap());
                config.rendezvous_server = host;
                config.store();
            }
        }
    }

    pub fn set_id(id: &str) {
        let mut config = CONFIG.write().unwrap();
        if id == config.id {
            return;
        }
        config.id = id.into();
        config.store();
    }

    
    pub fn set_nat_type(nat_type: i32) {
        let mut config = CONFIG2.write().unwrap();
        if nat_type == config.nat_type {
            return;
        }
        config.nat_type = nat_type;
        config.store();
    }

    pub fn get_nat_type() -> i32 {
        CONFIG2.read().unwrap().nat_type
    }

    pub fn set_serial(serial: i32) {
        let mut config = CONFIG2.write().unwrap();
        if serial == config.serial {
            return;
        }
        config.serial = serial;
        config.store();
    }

    pub fn get_serial() -> i32 {
        std::cmp::max(CONFIG2.read().unwrap().serial, SERIAL)
    }

    fn get_auto_id() -> Option<String> {
        #[cfg(any(target_os = "android", target_os = "ios"))]
        {
            return Some(
                rand::thread_rng()
                    .gen_range(1_000_000_000..2_000_000_000)
                    .to_string(),
            );
        }

        #[cfg(not(any(target_os = "android", target_os = "ios")))]
        {
            let mut id = 0u32;
            if let Ok(Some(ma)) = mac_address::get_mac_address() {
                for x in &ma.bytes()[2..] {
                    id = (id << 8) | (*x as u32);
                }
                id &= 0x1FFFFFFF;
                Some(id.to_string())
            } else {
                None
            }
        }
    }

    pub fn get_auto_password(length: usize) -> String {
        let mut rng = rand::thread_rng();
        (0..length)
            .map(|_| CHARS[rng.gen::<usize>() % CHARS.len()])
            .collect()
    }

    pub fn get_key_confirmed() -> bool {
        CONFIG.read().unwrap().key_confirmed
    }

    pub fn set_key_confirmed(v: bool) {
        let mut config = CONFIG.write().unwrap();
        if config.key_confirmed == v {
            return;
        }
        config.key_confirmed = v;
        if !v {
            config.keys_confirmed = Default::default();
        }
        config.store();
    }

    pub fn get_host_key_confirmed(host: &str) -> bool {
        matches!(CONFIG.read().unwrap().keys_confirmed.get(host), Some(true))
    }

    pub fn set_host_key_confirmed(host: &str, v: bool) {
        if Self::get_host_key_confirmed(host) == v {
            return;
        }
        let mut config = CONFIG.write().unwrap();
        config.keys_confirmed.insert(host.to_owned(), v);
        config.store();
    }

    pub fn get_key_pair() -> KeyPair {
        // lock here to make sure no gen_keypair more than once
        // no use of CONFIG directly here to ensure no recursive calling in Config::load because of password dec which calling this function
        let mut lock = KEY_PAIR.lock().unwrap();
        if let Some(p) = lock.as_ref() {
            return p.clone();
        }
        let mut config = Config::load_::<Config>("");
        if config.key_pair.0.is_empty() {
            let (pk, sk) = sign::gen_keypair();
            let key_pair = (sk.0.to_vec(), pk.0.into());
            config.key_pair = key_pair.clone();
            std::thread::spawn(|| {
                let mut config = CONFIG.write().unwrap();
                config.key_pair = key_pair;
                config.store();
            });
        }
        *lock = Some(config.key_pair.clone());
        config.key_pair
    }

    pub fn get_id() -> String {
        let mut id = CONFIG.read().unwrap().id.clone();
        if id.is_empty() {
            if let Some(tmp) = Config::get_auto_id() {
                id = tmp;
                Config::set_id(&id);
            }
        }
        id
    }

    pub fn get_id_or(b: String) -> String {
        let a = CONFIG.read().unwrap().id.clone();
        if a.is_empty() {
            b
        } else {
            a
        }
    }

    pub fn get_options() -> HashMap<String, String> {
        CONFIG2.read().unwrap().options.clone()
    }

    pub fn set_options(v: HashMap<String, String>) {
        let mut config = CONFIG2.write().unwrap();
        if config.options == v {
            return;
        }
        config.options = v;
        config.store();
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = CONFIG2.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = CONFIG2.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }

    pub fn update_id() {
        // to-do: how about if one ip register a lot of ids?
        let id = Self::get_id();
        let mut rng = rand::thread_rng();
        let new_id = rng.gen_range(1_000_000_000..2_000_000_000).to_string();
        Config::set_id(&new_id);
        log::info!("id updated from {} to {}", id, new_id);
    }

    pub fn set_permanent_password(password: &str) {
        let mut config = CONFIG.write().unwrap();
        if password == config.password {
            return;
        }
        config.password = password.into();
        config.store();
    }
    //function to store the Registered_mail_id in the login_id variable
    pub fn set_login_id(login_id: &str) {
        let mut config = CONFIG.write().unwrap();
        if login_id == config.login_id {
            return;
        }
        config.login_id = login_id.into();
        config.store();
    }

    //function to get the Registered_mail_id from the login_id variable
    pub fn get_login_id() -> String {
        CONFIG.read().unwrap().login_id.clone()
    }

    //function to store the notify email_id in the email_id variable
    pub fn set_email_id(email_id: &str) {
        let mut config = CONFIG.write().unwrap();
        if email_id == config.email_id {
            return;
        }
        config.email_id = email_id.into();
        config.store();
    }

    //function to get the notify email_id from the email_id variable
    pub fn get_email_id() -> String {
        CONFIG.read().unwrap().email_id.clone()
    }

    //function to store the expiry_date of the product
    pub fn set_expiry_date(expiry_date: &str) {
        let mut config = CONFIG.write().unwrap();
        if expiry_date == config.expiry_date {
            return;
        }
        config.expiry_date = expiry_date.into();
        config.store();
    }

     //function to get the expiry_date of the product
    pub fn get_expiry_date() -> String {
        CONFIG.read().unwrap().expiry_date.clone()
    }

     //function to store the Registered user password in login_password variable
    pub fn set_login_password(login_password: &str) {
        let mut config = CONFIG.write().unwrap();
        if login_password == config.login_password {
            return;
        }
        config.login_password = login_password.into();
        config.store();
    }

    pub fn get_login_password() -> String {
        CONFIG.read().unwrap().login_password.clone()
    }


    //function to get the Registered user password from login_password variable
    pub fn get_permanent_password() -> String {
        CONFIG.read().unwrap().password.clone()
    }

    //function to store the license_key in key_license variable
    pub fn set_license_key(key_license: &str) {
        let mut config = CONFIG.write().unwrap();
        if key_license == config.key_license {
            return;
        }
        config.key_license = key_license.into();
        config.store();
    }

     //function to get the license_key from the  key_license variable
    pub fn get_license_key() -> String {
        CONFIG.read().unwrap().key_license.clone()
    }

    //function to store the reachdesk_serverip in reachdesk_serverip variable
    pub fn set_reachdeskserver_ip(reachdesk_serverip: &str) {
        let mut config = CONFIG.write().unwrap();
        if reachdesk_serverip == config.reachdesk_serverip {
            return;
        }
        config.reachdesk_serverip = reachdesk_serverip.into();
        config.store();
    }

    //function to get the reachdesk_serverip from the  reachdesk_serverip variable
    pub fn get_reachdesk_serverip() -> String {
        CONFIG.read().unwrap().reachdesk_serverip.clone()
    }

    pub fn set_salt(salt: &str) {
        let mut config = CONFIG.write().unwrap();
        if salt == config.salt {
            return;
        }
        config.salt = salt.into();
        config.store();
    }

    pub fn get_salt() -> String {
        let mut salt = CONFIG.read().unwrap().salt.clone();
        if salt.is_empty() {
            salt = Config::get_auto_password(6);
            Config::set_salt(&salt);
        }
        salt
    }

    pub fn set_socks(socks: Option<Socks5Server>) {
        let mut config = CONFIG2.write().unwrap();
        if config.socks == socks {
            return;
        }
        config.socks = socks;
        config.store();
    }

    pub fn get_socks() -> Option<Socks5Server> {
        CONFIG2.read().unwrap().socks.clone()
    }

    pub fn get_network_type() -> NetworkType {
        match &CONFIG2.read().unwrap().socks {
            None => NetworkType::Direct,
            Some(_) => NetworkType::ProxySocks,
        }
    }

    pub fn get() -> Config {
        return CONFIG.read().unwrap().clone();
    }

    pub fn set(cfg: Config) -> bool {
        let mut lock = CONFIG.write().unwrap();
        if *lock == cfg {
            return false;
        }
        *lock = cfg;
        lock.store();
        true
    }

    fn with_extension(path: PathBuf) -> PathBuf {
        let ext = path.extension();
        if let Some(ext) = ext {
            let ext = format!("{}.toml", ext.to_string_lossy());
            path.with_extension(ext)
        } else {
            path.with_extension("toml")
        }
    }
}

const PEERS: &str = "peers";

impl PeerConfig {
    pub fn load(id: &str) -> PeerConfig {
        let _lock = CONFIG.read().unwrap();
        match confy::load_path(Self::path(id)) {
            Ok(config) => {
                let mut config: PeerConfig = config;
                let mut store = false;
                let (password, _, store2) =
                    decrypt_vec_or_original(&config.password, PASSWORD_ENC_VERSION);
                config.password = password;
                store = store || store2;
                if let Some(v) = config.options.get_mut("rdp_password") {
                    let (password, _, store2) = decrypt_str_or_original(v, PASSWORD_ENC_VERSION);
                    *v = password;
                    store = store || store2;
                }
                if let Some(v) = config.options.get_mut("os-password") {
                    let (password, _, store2) = decrypt_str_or_original(v, PASSWORD_ENC_VERSION);
                    *v = password;
                    store = store || store2;
                }
                if store {
                    config.store(id);
                }
                config
            }
            Err(err) => {
                log::error!("Failed to load config: {}", err);
                Default::default()
            }
        }
    }

    pub fn store(&self, id: &str) {
        let _lock = CONFIG.read().unwrap();
        let mut config = self.clone();
        config.password = encrypt_vec_or_original(&config.password, PASSWORD_ENC_VERSION);
        if let Some(v) = config.options.get_mut("rdp_password") {
            *v = encrypt_str_or_original(v, PASSWORD_ENC_VERSION)
        }
        if let Some(v) = config.options.get_mut("os-password") {
            *v = encrypt_str_or_original(v, PASSWORD_ENC_VERSION)
        };
        if let Err(err) = store_path(Self::path(id), config) {
            log::error!("Failed to store config: {}", err);
        }
    }

    pub fn remove(id: &str) {
        fs::remove_file(Self::path(id)).ok();
    }

    fn path(id: &str) -> PathBuf {
        //If the id contains invalid chars, encode it
        let forbidden_paths = Regex::new(r".*[<>:/\\|\?\*].*").unwrap();
        let id_encoded = if forbidden_paths.is_match(id) {
            "base64_".to_string() + base64::encode(id, base64::Variant::Original).as_str()
        } else {
            id.to_string()
        };
        let path: PathBuf = [PEERS, id_encoded.as_str()].iter().collect();
        Config::with_extension(Config::path(path))
    }

    pub fn peers() -> Vec<(String, SystemTime, PeerConfig)> {
        if let Ok(peers) = Config::path(PEERS).read_dir() {
            if let Ok(peers) = peers
                .map(|res| res.map(|e| e.path()))
                .collect::<Result<Vec<_>, _>>()
            {
                let mut peers: Vec<_> = peers
                    .iter()
                    .filter(|p| {
                        p.is_file()
                            && p.extension().map(|p| p.to_str().unwrap_or("")) == Some("toml")
                    })
                    .map(|p| {
                        let t = crate::get_modified_time(p);
                        let id = p
                            .file_stem()
                            .map(|p| p.to_str().unwrap_or(""))
                            .unwrap_or("")
                            .to_owned();

                        let id_decoded_string = if id.starts_with("base64_") && id.len() != 7 {
                            let id_decoded = base64::decode(&id[7..], base64::Variant::Original)
                                .unwrap_or_default();
                            String::from_utf8_lossy(&id_decoded).as_ref().to_owned()
                        } else {
                            id
                        };

                        let c = PeerConfig::load(&id_decoded_string);
                        if c.info.platform.is_empty() {
                            fs::remove_file(p).ok();
                        }
                        (id_decoded_string, t, c)
                    })
                    .filter(|p| !p.2.info.platform.is_empty())
                    .collect();
                peers.sort_unstable_by(|a, b| b.1.cmp(&a.1));
                return peers;
            }
        }
        Default::default()
    }

    serde_field_string!(
        default_view_style,
        deserialize_view_style,
        "original".to_owned()
    );
    serde_field_string!(
        default_scroll_style,
        deserialize_scroll_style,
        "scrollauto".to_owned()
    );
    serde_field_string!(
        default_image_quality,
        deserialize_image_quality,
        "balanced".to_owned()
    );

    fn deserialize_options<'de, D>(deserializer: D) -> Result<HashMap<String, String>, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let mut mp: HashMap<String, String> = de::Deserialize::deserialize(deserializer)?;
        if !mp.contains_key("codec-preference") {
            mp.insert("codec-preference".to_owned(), "auto".to_owned());
        }
        Ok(mp)
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LocalConfig {
    #[serde(default)]
    remote_id: String, // latest used one
    #[serde(default)]
    kb_layout_type: String,
    #[serde(default)]
    size: Size,
    #[serde(default)]
    pub fav: Vec<String>,
    #[serde(default)]
    options: HashMap<String, String>,
    // Various data for flutter ui
    #[serde(default)]
    ui_flutter: HashMap<String, String>,
}

impl LocalConfig {
    fn load() -> LocalConfig {
        Config::load_::<LocalConfig>("_local")
    }

    fn store(&self) {
        Config::store_(self, "_local");
    }

    pub fn get_kb_layout_type() -> String {
        LOCAL_CONFIG.read().unwrap().kb_layout_type.clone()
    }

    pub fn set_kb_layout_type(kb_layout_type: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        config.kb_layout_type = kb_layout_type;
        config.store();
    }

    pub fn get_size() -> Size {
        LOCAL_CONFIG.read().unwrap().size
    }

    pub fn set_size(x: i32, y: i32, w: i32, h: i32) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let size = (x, y, w, h);
        if size == config.size || size.2 < 300 || size.3 < 300 {
            return;
        }
        config.size = size;
        config.store();
    }

    pub fn set_remote_id(remote_id: &str) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        if remote_id == config.remote_id {
            return;
        }
        config.remote_id = remote_id.into();
        config.store();
    }

    pub fn get_remote_id() -> String {
        LOCAL_CONFIG.read().unwrap().remote_id.clone()
    }

    pub fn set_fav(fav: Vec<String>) {
        let mut lock = LOCAL_CONFIG.write().unwrap();
        if lock.fav == fav {
            return;
        }
        lock.fav = fav;
        lock.store();
    }

    pub fn get_fav() -> Vec<String> {
        LOCAL_CONFIG.read().unwrap().fav.clone()
    }

    pub fn get_option(k: &str) -> String {
        if let Some(v) = LOCAL_CONFIG.read().unwrap().options.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_option(k: String, v: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.options.get(&k) {
            if v2.is_none() {
                config.options.remove(&k);
            } else {
                config.options.insert(k, v);
            }
            config.store();
        }
    }

    pub fn get_flutter_config(k: &str) -> String {
        if let Some(v) = LOCAL_CONFIG.read().unwrap().ui_flutter.get(k) {
            v.clone()
        } else {
            "".to_owned()
        }
    }

    pub fn set_flutter_config(k: String, v: String) {
        let mut config = LOCAL_CONFIG.write().unwrap();
        let v2 = if v.is_empty() { None } else { Some(&v) };
        if v2 != config.ui_flutter.get(&k) {
            if v2.is_none() {
                config.ui_flutter.remove(&k);
            } else {
                config.ui_flutter.insert(k, v);
            }
            config.store();
        }
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct DiscoveryPeer {
    #[serde(default)]
    pub id: String,
    #[serde(default)]
    pub username: String,
    #[serde(default)]
    pub hostname: String,
    #[serde(default)]
    pub platform: String,
    #[serde(default)]
    pub online: bool,
    #[serde(default)]
    pub ip_mac: HashMap<String, String>,
}

impl DiscoveryPeer {
    pub fn is_same_peer(&self, other: &DiscoveryPeer) -> bool {
        self.id == other.id && self.username == other.username
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct LanPeers {
    pub peers: Vec<DiscoveryPeer>,
}

impl LanPeers {
    pub fn load() -> LanPeers {
        let _lock = CONFIG.read().unwrap();
        match confy::load_path(Config::file_("_lan_peers")) {
            Ok(peers) => peers,
            Err(err) => {
                log::error!("Failed to load lan peers: {}", err);
                Default::default()
            }
        }
    }

    pub fn store(peers: &[DiscoveryPeer]) {
        let f = LanPeers {
            peers: peers.to_owned(),
        };
        if let Err(err) = store_path(Config::file_("_lan_peers"), f) {
            log::error!("Failed to store lan peers: {}", err);
        }
    }

    pub fn modify_time() -> crate::ResultType<u64> {
        let p = Config::file_("_lan_peers");
        Ok(fs::metadata(p)?
            .modified()?
            .duration_since(SystemTime::UNIX_EPOCH)?
            .as_millis() as _)
    }
}

#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct HwCodecConfig {
    #[serde(default)]
    pub options: HashMap<String, String>,
}

impl HwCodecConfig {
    pub fn load() -> HwCodecConfig {
        Config::load_::<HwCodecConfig>("_hwcodec")
    }

    pub fn store(&self) {
        Config::store_(self, "_hwcodec");
    }

    pub fn remove() {
        std::fs::remove_file(Config::file_("_hwcodec")).ok();
    }

    /// refresh current global HW_CODEC_CONFIG, usually uesd after HwCodecConfig::remove()
    pub fn refresh() {
        *HW_CODEC_CONFIG.write().unwrap() = HwCodecConfig::load();
        log::debug!("HW_CODEC_CONFIG refreshed successfully");
    }

    pub fn get() -> HwCodecConfig {
        return HW_CODEC_CONFIG.read().unwrap().clone();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize() {
        let cfg: Config = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
        let cfg: PeerConfig = Default::default();
        let res = toml::to_string_pretty(&cfg);
        assert!(res.is_ok());
    }
}
